---
title: poj-1061 扩展欧几里得
date: 2017-03-13 00:03:34
categories: ACM
tags:  [数论,题解]
---

## 扩展欧几里得
第一次写扩展欧几里得，感觉最重要的还是最开始就搞懂定理的推导过程，不然会遇到一些坑，在这里简单的mark一下我的理解。 

### 原理
扩展欧几里得德递归形式和gcd类似，关键在于中途对x,y的处理，重点在理解一下方程的推导：   
**ax1+by1=gcd(a,b)**  ....1  
**bx2+ay2=gcd(b,a%b)**  ....2  
**gcd(a,b)=gcd(b,a%b)**  ....3  

化简可以得到：x1=y2 y1=x2-a/b*y2  之后便不难理解边界条件设为b=0时，最终可以推出来方程1的一组解x0,y0  
  
### 推论
重点在于其得到的推论：**ax+by=c 仅当cMODgcd(a,b)=0 时有解**  
设 c = k*gcd(a,b)  
上式可以化简为 a/gcd(a,b)*x + b/gcd(a,b)*y = k   =>  Ax+By=k  
显然AB互质，因而满足方程的解系为(x0-nB,x0+nA) n为任意整数  

## 题解
就这道题目来说，我觉得对新手来说坑还是有几个：  
1. 将追逐问题转化为ax+by=c 的不定方程组的解的问题，即确定a和b.
2. 将exgcd求得的解转化为原方程的解（判断是否有解），并最小化

### 代码
```c++
#include <iostream>

#define ABS(x) (((x)>0)?(x):(-(x)))
#define LL long long
using namespace std;

//ax+by = gcd(a,b)
void exgcd(LL a,LL b,LL &x,LL &y,LL &d)
{
	if(b==0){
		x = 1; y = 0; d =a;
		return;
	}
	exgcd(b,a%b,x,y,d);
	LL t=x;
	x = y;
	y = t - (a/b)*y;
	return;
}


int main()
{
	LL x,y,m,n,l;
	cin>>x>>y>>m>>n>>l;
	LL v,dis,d,x0,y0;
	v  = ABS(m-n);
	if(m>n)
		dis = (y-x+l)%l;
	else
		dis = (x-y+l)%l;
		
	exgcd(v,l,x0,y0,d);
	
	if(d&&dis%d==0){
		x0 = x0*dis/d;
		LL t = l/d;
		x0 = (x0%t+t)%t;
		cout<<x0<<endl;
	}
	else{
		cout<<"Impossible"<<endl;
	}
}

```
