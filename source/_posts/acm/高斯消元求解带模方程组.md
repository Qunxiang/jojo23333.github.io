---
title: 高斯消元求解带模方程组
date: 2017-09-21 02:26:04
tags: [高斯消元]
categories: ACM
---

HDU-5755  
一类开关问题  
做法是设第一行各个位置操作为x1~xn次那么就可以最后一直推下去  
推出第n+1行所需要的操作个数一定都为0,这样就得到了一个n个变量的方程组  
用高斯消元求出解都推出来就行


```c++
const int MOD = 3;
const int INF = 0x3f3f3f3f;
int a[MAXN][MAXN];
int x[MAXN];

inline int gcd(int a,int b)
{
	int t;
	while(b != 0){
		t = b;
		b = a%b;
		a = t;
	}
	return a;
}

inline void exgcd(int a,int b,int &x,int &y,int &d)
{
	if(b==0){
		x = 1; y=0; d = a;	return;
	}
	exgcd(b,a%b,x,y,d);
	int t = x;
	x = y;
	y = t - (a/b)*y;
	return;
}

int lcm(int a,int b){
	return a*b/gcd(a,b);
}

int inv(int a,int mod)
{
	int x,y,d;
	exgcd(a,mod,x,y,d);
	return (x+mod)%mod;
}

int gauss(int rows,int var)
{
	int col,k,max_r;
	for(col=0,k=0; col<var && k<rows; col++,k++){
		max_r = k;
		for(int i=k+1; i<rows; i++)
			if(abs(a[i][col])>abs(a[k][col]))
				max_r = i;
		if(a[max_r][col]==0){
			k--; continue;	//Jump to next variable
		}
		if(max_r!=k)
			for(int i=0; i<var+1; i++)
				swap(a[k][i],a[max_r][i]);
		for(int i=k+1; i<rows; i++){
			if(a[i][col]!=0){
				int LCM = lcm(a[k][col],a[i][col]);
				int tk = LCM/a[k][col];
				int ti = LCM/a[i][col];
				for(int j=col; j<var+1; j++)
					a[i][j] = ((a[i][j]*ti - a[k][j]*tk)%MOD+MOD)%MOD;
			}
		}
	}
	for(int i=k; i<rows; i++)
		if(a[i][col]!=0)
			return -1;				//
	if(rows<var) return rows-var;	//

	for(int i=var-1; i>=0; i--){
		int temp = a[i][var];
		for(int j=i+1; j<var; j++)
		{
			if(a[i][j]!=0){
				temp -= a[i][j]*x[j];
				temp = (temp%MOD+MOD)%MOD;
			}
		}
		x[i] = (temp*inv(a[i][i],MOD))%MOD;
	}
	return 0;
}

int T,N,M;
int m[50][50];
int f[50][50][50];
int p[50][50];

int get(int i,int j,int k)
{
    int ans = (f[i][j-1][k]+2*f[i][j][k]+f[i][j+1][k]+f[i-1][j][k])%MOD;
    return ((3-ans)%MOD+MOD)%MOD;
}

int getans(int i,int j)
{
    int ans = (p[i][j-1]+2*p[i][j]+p[i][j+1]+p[i-1][j]+m[i][j])%MOD;
    return ((3-ans)%MOD+MOD)%MOD;
}

int main()
{
	sc(T);
	while(T--){
		sc(N);	sc(M);
		for(int i=1; i<=N; i++)
			for(int j=1; j<=M; j++)
				sc(m[i][j]);
		memset(a,0,sizeof(a));
        memset(f,0,sizeof(f));
        memset(p,0,sizeof(p));
		for(int i=1; i<=M; i++)
			f[0][i][i] = 1;
		int cur = 0;
        for(int i=1; i<=N; i++){
            for(int j=1; j<=M; j++){
                for(int k=1; k<=M; k++)
                    f[i][j][k] = get(i-1,j,k);
                f[i][j][M+1] = (3 - m[i][j] + get(i-1,j,M+1))%MOD;
            }
        }
		for(int i=0; i<M; i++){
            for(int j=0; j<M; j++)
                a[i][j] = f[N][i+1][j+1];
            a[i][M] = (3-f[N][i+1][M+1])%MOD;
		}
        gauss(M,M);
        int ans = 0;
        for(int i=1; i<=M; i++)
            p[1][i] = x[i-1],ans += p[1][i];
        for(int i=2; i<=N; i++)
            for(int j=1; j<=M; j++)
                p[i][j] = getans(i-1,j),ans += p[i][j];
        printf("%d\n",ans);
        for(int i=1; i<=N; i++)
            for(int j=1; j<=M; j++)
                for(int k=0; k<p[i][j]; k++)
                    printf("%d %d\n",i,j);
	}
}
```
