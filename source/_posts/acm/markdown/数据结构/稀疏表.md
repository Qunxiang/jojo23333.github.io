---
title: 稀疏表
date: 2017-8-20 12:03:34
categories: ACM
tags:  [RMQ,稀疏表]
---

## Spared Table （用于解决多种RMQ问题）
模板：
（解决区间极小值）
```c++
/*
ST用来O（nlogn）时间预处理，O（1）时间查询最大最小值
*/
#include <iostream>  
#include <math.h>  
using namespace std;  
  
/*方程 
F[i,j]:区间[i,i + 2^j - 1]的最小值，此时区间长度为2^j 
F[i,j] = min(F[i,j - 1],F[i + 2^(j - 1),j - 1]) 
F[i,0] = nArr[i];*/  
  
const int MAXN = 10010;
int rmq[2*MAXN];//rmq数组,就是欧拉序列对应的深度序列
  
struct ST
{
    int mm[2*MAXN];//意思是向下取log2(k)
    int dp[2*MAXN][20];//最小值对应的下标
    void init(int n)
    {
        mm[0] = -1;
        for(int i = 1;i <= n;i++)
        {
            mm[i] = ((i&(i-1)) == 0)?mm[i-1]+1:mm[i-1];
            dp[i][0] = i;
        }
        for(int j = 1; j <= mm[n];j++)
            for(int i = 1; i + (1<<j) - 1 <= n; i++)
                dp[i][j] = rmq[dp[i][j-1]] <
                rmq[dp[i+(1<<(j-1))][j-1]]?dp[i][j-1]:dp[i+(1<<(j-1))][j-1];
    }
    int query(int a,int b)//查询[a,b]之间最小值的下标
    {
        if(a > b)swap(a,b);
        int k = mm[b-a+1];
        return rmq[dp[a][k]] <= 
        rmq[dp[b-(1<<k)+1][k]]?dp[a][k]:dp[b-(1<<k)+1][k];
    }
};
```

例：hdu-5726 解决区间最小公倍数
