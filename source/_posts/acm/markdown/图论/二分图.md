---
title: 二分图最大匹配的匈牙利算法和性质
date: 2017-8-20 12:03:34
categories: ACM
tags:  [二分图]
---

# 二分图最大匹配

## 最大匹配的匈牙利算法
### 最大匹配：
在G的一个子图M中，M的边集中的任意两条边都不依附于 同一个顶点，则称M是一个匹配。选择这样的边数最大的子集称为图的最大匹配问题,最大匹配的边数称为最大匹配数.如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。如果在左右两边加上源汇点后，图G等价于一个网络流，最大匹配问题可以转为最大流的问题。解决此问的匈牙利算法的本质就是寻找最大流的增广路径。  

模板如下
```c++
/*
    匈牙利算法
    解决最大匹配问题
    临接表版本
*/
struct edge{
    int to,next;
}edge[MAXN];
int head[MAXN],tot;
void init()
{
    tot = 0;
    memset(head,-1,sizeof(head));
}

void addedge(int u,int v)
{
    edge[tot].to = v;   edge[tot].next = head[u];
    head[u] = tot++;
}
int linker[MAXN];
int used[MAXN];
int uN;         //点的编号0~uN-1

bool dfs(int u)
{
    for(int i=head[u]; i!=-1; i=edge[i].next)
    {
        int v = edge[i].to;
        if(!used[v])
        {
            used[v] = true;
            if(linker[v]==-1 || dfs(linker[v])){
                linker[v] = u;
                return true;
            }
        }
    }
    return false;
}

int hungary()
{
    int res = 0;
    memset(linker,-1,sizeof(linker));
    for(itn u=0; u<uN; u++){
        memset(used,false,sizeof(used));
        if(dfs(u))  res++;
    }
    return res;
}

/*
邻接矩阵的匈牙利算法
最小点覆盖等价于最大匹配，对每一个X集合未覆盖点出发进行一次匈牙利树扩展（dfs（））最后X内未标记和Y内已标记的集合组成最小覆盖
min_cover用来通过扩展匈牙利树寻找最小点覆盖
*/
int R,C,N;
int uN,vN;
int G[MAXN][MAXN];
int Left[MAXN];
int Right[MAXN];
bool S[MAXN],T[MAXN];

bool dfs(int u)
{
    S[u] = true;
    for(int v=1; v<=vN;v++)
    if(G[u][v] && !T[v]){
        T[v] = true;
        if(Left[v] == -1 || dfs(Left[v])){
            Right[u] = v;
            Left[v] = u;
            return true;
        }
    }
    return false;
}

int hungary()
{
    int res = 0;
    memset(Left,-1,sizeof(Left));
    memset(Right,-1,sizeof(Right));
    for(int u=1; u<=uN; u++){
        memset(T,0,sizeof(T));
        if(dfs(u)) res++;
    }
    return res;
}

int min_cover(vector<int> &X,vector<int> &Y)
{
    int ans = hungary();
    X.clear();  Y.clear();
    memset(S,0,sizeof(S));
    memset(T,0,sizeof(T));
    for(int i=1;i<=uN;i++)
        if(Right[i]==-1) dfs(i);
    for(int i=1;i<=uN;i++)
        if(!S[i]) X.pb(i);
    for(int j=1;j<=vN;j++)
        if(T[j]) Y.pb(j);
    return ans;
}
```


## 二分图的一些特有性质
### 最小覆盖
1. **最小定点覆盖**:  
    最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联，二分图的最小顶点覆盖数=二分图的最大匹配数。  
**最小定点覆盖的证明**：  
首先，最小点集覆盖一定>=最大匹配，因为假设最大匹配为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就要用到n个点。现在我们来思考为什么最小点击覆盖一定<=最大匹配。任何一种n个点的最小点击覆盖，一定可以转化成一个n的最大匹配。因为最小点集覆盖中的每个点都能找到至少一条只有一个端点在点集中的边（如果找不到则说明该点所有的边的另外一个端点都被覆盖，所以该点则没必要被覆盖，和它在最小点集覆盖中相矛盾），只要每个端点都选择一个这样的边，就必然能转化为一个匹配数与点集覆盖的点数相等的匹配方案。所以最大匹配至少为最小点集覆盖数，即最小点击覆盖一定<=最大匹配。综上，二者相等。

2. **最小边覆盖**：  
    最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图的最小路径覆盖数=|V|-二分图的最大匹配数。  
    **最小边覆盖的证明**：  
不妨设最小定点覆盖为X一共V个点，那么，最小边覆盖一定》=V-X。原因在于，首先根据最小点覆盖覆盖所有边的性质，最小点覆盖没取到的V-X条边两两无边相连，**也就是说他们是一个独立子集**，那么最小边覆盖要取到所有点的话就需要这V-X个点每个点取一条边。同时V-X又是取得到的，由于原图最小顶点覆盖就是最大二分匹配，每次取边的是后总是遵循是匹配边的话取匹配边，否则任取。那么结果一定取到了所有定点 



**从二分最大匹配找到最小点覆盖**    
需要借助匈牙利树： 设二分图两个集合为X Y  
从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖

### 最大独立集
**最大独立集=V-最小覆盖集=V-最大匹配**  

![](/images/二分图.png)    
上图，我们用两个红色的点覆盖了所有边。我们证明的前提条件是已经达到最小覆盖。
即条件1.已经覆盖所有边，条件2.所用的点数最小  
**首先我们来证明蓝色点组成的是一个独立集：**   
如果有两个蓝色点间有边相连，那么这条边则没有被覆盖，则与条件1矛盾。因此是独立集。  
**再来证明这个独立集最大：**  
如果我们要再增加这个独立集中的点，则需要把某个红点变成蓝点。而由最小覆盖数=最大匹配数的证明我们知道，每一个红点是最大匹配中的一个匹配点，也就是说每个红点至少连接了一条边。因此当我们将某个红点变成蓝点时，我们需要牺牲的蓝点的个数是大于等于1的。也就是说，我们最多只能找到数量相等的其他独立集，而无法找到数量更大的。因此蓝色点集必定为最大独立集。 蓝色点数 =总点数 - 红色点数，即最大独立集=总数-最小覆盖集。

    