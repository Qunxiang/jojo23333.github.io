---
title: Uva-14149 二分图匹配求最小点覆盖
date: 2017-8-28 12:03:34
categories: ACM
tags:  [二分图,最小点覆盖]
---

# Uva-14149
## 题意：   
给一个R*C的矩形网格，每一个小格子内可能有点，求最小选多少行多少列可以覆盖所有的点，并输出这些行和列


## 题解：
由于类似一个覆盖问题，可以想办法根据矩阵的二维性质构造一个二分图求最小覆盖 。  
那么使每一行为一个点集每一列为一个点集，(x,y)有点则在x和y之间连一条线。那么最后只需要选点覆盖所有线就行。  
二分匹配->最小点覆盖  
要具体求出哪些点参考以下结论
### 一个结论
**从二分最大匹配找到最小点覆盖**    
需要借助匈牙利树： 设二分图两个集合为X Y  
从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖

```c++
int R,C,N;
int uN,vN;
int G[MAXN][MAXN];
int Left[MAXN];
int Right[MAXN];
bool S[MAXN],T[MAXN];

bool dfs(int u)
{
    S[u] = true;
    for(int v=1; v<=vN;v++)
    if(G[u][v] && !T[v]){
        T[v] = true;
        if(Left[v] == -1 || dfs(Left[v])){
            Right[u] = v;
            Left[v] = u;
            return true;
        }
    }
    return false;
}

int hungary()
{
    int res = 0;
    memset(Left,-1,sizeof(Left));
    memset(Right,-1,sizeof(Right));
    for(int u=1; u<=uN; u++){
        memset(T,0,sizeof(T));
        if(dfs(u)) res++;
    }
    return res;
}

int min_cover(vector<int> &X,vector<int> &Y)
{
    int ans = hungary();
    X.clear();  Y.clear();
    memset(S,0,sizeof(S));
    memset(T,0,sizeof(T));
    for(int i=1;i<=uN;i++)
        if(Right[i]==-1) dfs(i);
    for(int i=1;i<=uN;i++)
        if(!S[i]) X.pb(i);
    for(int j=1;j<=vN;j++)
        if(T[j]) Y.pb(j);
    return ans;
}

int main()
{
    vector<int> x,y;
    while(scanf("%d%d%d",&R,&C,&N)){
        if(R==0 && C==0 && N==0)
            break;
        uN = R; vN = C;
        memset(G,0,sizeof(G));
        for(int i=0; i<N; i++){
            int y,x;
            sc(y); sc(x);
            G[y][x] = 1;
        }
        int ans = min_cover(x,y);
        printf("%d",ans);
        for(int i=0; i<x.size(); i++)
            printf(" r%d",x[i]);
        for(int i=0; i<y.size(); i++)
            printf(" c%d",y[i]);
        printf("\n");
    }
}
```