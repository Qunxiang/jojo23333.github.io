---
title: 求最小割最少边数
date: 2017-09-18 22:01:39
tags: [网络流]
categories: ACM
---
给有向图，求一个最小割，它的边数也最小  
搜了原题题解，发现一堆假算法==  
假算法说什么将满流边置为1 其它边置为INF 感觉不科学
因为考虑有不同种最大流情况的图，不同的最大流情况会导致算出来的结果不一样。

AC的解法是对于每条边的容量乘上一个大于边数的数+1,最后再模上这个数。

```c++
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <utility>
#include <queue>
#define MAXN 5000
#define sc(x) scanf("%d",&(x))

using namespace std;
const int INF = 0x3f3f3f3f;

struct edge{
	int t,cap,next;
};
edge e[MAXN];
int cnt;
int head[MAXN];
int n,m,s,t;
int iter[MAXN],level[MAXN];

void add_edge(int f,int t,int cap){
	e[cnt].t = t;	e[cnt].cap = cap;	e[cnt].next = head[f];
	head[f] = cnt++;
	e[cnt].t = f;	e[cnt].cap = 0;	e[cnt].next = head[t];
	head[t] = cnt++;
}

void bfs(int s,int t)
{
	memset(level,-1,sizeof(level));
	level[s] = 0;
	queue<int> q;
	q.push(s);
	while(!q.empty()){
		int cur = q.front(); q.pop();
		if(cur==t) break;
		for(int i=head[cur]; i!=-1; i=e[i].next){
			int v = e[i].t;
			if(level[v]<0 && e[i].cap>0){
				level[v] = level[cur] + 1;
				q.push(v);
			}	
		}
	}
}

int dfs(int u,int t,int flow)
{
	if(u==t) return flow;
	for(int &i=iter[u]; i!=-1; i=e[i].next){
		int v = e[i].t;
		if(level[v]>level[u] && e[i].cap>0){
			int val = dfs(v,t,min(flow,e[i].cap));
			if(val>0){
				e[i].cap -= val;
				e[i^1].cap +=val;
				return val;
			}
		}
	}
	return 0;
}


int Dinic()
{
	int ans = 0;
	while(1){
		bfs(s,t);
	//	for(int i=1; i<=n; i++)
	//		cout<<"level "<<i<<": "<<level[i]<<endl;
		if(level[t]<0) break;
		for(int i=1; i<=n; i++)
			iter[i] = head[i];
		int val;
		while(val=dfs(s,t,INF)){
			//cout<<"val: "<<val<<endl;
			ans += val;
		}
	}
	return ans;
}

int main()
{
	int T;
	sc(T);
	while(T--){
		sc(n); sc(m);
		sc(s); sc(t);
		cnt = 0;
		memset(head,-1,sizeof(head));
		for(int i=0; i<m; i++){
			int u,v,w;
			sc(u); sc(v); sc(w);
			add_edge(u,v,w*1000+1);
		}
		int ans = Dinic();
		cout<<ans%1000<<endl;
	}
}


```

