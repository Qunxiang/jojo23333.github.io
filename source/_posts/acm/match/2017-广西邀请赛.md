---
title: 2017-广西邀请赛
date: 2017-08-27 17:25:04
tags: [比赛,题解,三元环]
categories: ACM
---
算是我队第一次打正式赛了吧..全场贡献了几题思路..打表大法是真的强..  
终榜5题银..还行..

### 记录几个要补的题：   
1. C: 怎么求三元环
2. G: 平面图转对偶图
3. K： 暴力哈希KMP

### C
```c++
#include <iostream>
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <vector>
#include <set>
#include <stack>
#include <sstream>
#include <queue>
#include <map>
#include <functional>
#include <bitset>

using namespace std;
#define pb push_back
#define mk make_pair
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define mkp make_pair
#define fst first
#define scd second
#define ALL(A) A.begin(), A.end()
#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)
#define REP1(i, n) for(int (i)=1;(i)<=(int)(n);(i)++)
#define fastio ios::sync_with_stdio(0), cin.tie(0)
#define frein freopen("in.txt", "r", stdin)
#define freout freopen("out.txt", "w", stdout)
#define freout1 freopen("out1.txt", "w", stdout)
#define PI M_PI
#define MAXN 100000
#define xork(a,b) ((b&1)?(a):(0))
#define sc(n) scanf("%d",&(n))

ll mod = 10000;
ll INF = 1LL<<60LL;
const double eps = 1e-8;
template<typename T> T gcd(T a,T b)
{if(!b)return a;return gcd(b,a%b);}
struct edge{
    int from,to,nxt;
}E[MAXN*2];
map<pii,int> mp;
int head[MAXN];
int cnt;
int edgecnt[MAXN];
int d[MAXN];
int node[MAXN];
int ncnt;

void add_edge(int f,int t){
    E[cnt].to = t; E[cnt].nxt = head[f];
    head[f] = cnt;
    mp[mkp(f,t)] = cnt/2;
    mp[mkp(t,f)] = cnt/2;
    cnt++;
    E[cnt].to = f; E[cnt].nxt = head[t];
    head[t] = cnt;
    cnt++;
}

int main()
{
    //freout;
    int n,m;
    while(~scanf("%d%d",&n,&m)){
        cnt = 0;
        memset(head,-1,sizeof(head));
        memset(d,0,sizeof(d));
        memset(edgecnt,0,sizeof(edgecnt));
        mp.clear();
        for(int i=0; i<m; i++){
            int u,v;
            sc(u); sc(v);
            add_edge(u,v);
            d[u]++,d[v]++;
        }
        int x = (int)sqrt(m);
        ncnt = 0;
        for(int i=1; i<=n; i++){
            if(d[i]<=x){
                for(int j=head[i]; j!=-1; j=E[j].nxt){
                    int u = E[j].to;
                    for(int k=E[j].nxt; k!=-1; k=E[k].nxt){
                        int v = E[k].to;
                        if(mp.count(mkp(u,v))){
                            edgecnt[mp[mkp(u,v)]]++;
                        }
                    }
                }
            }
            else{
                node[ncnt++] = i;
            }
        }
        for(int i=0; i<ncnt; i++){
            int u = node[i];
            for(int j=i+1; j<ncnt; j++){
                int v = node[j];
                if(mp.count(mkp(u,v)))
                for(int k=j+1; k<ncnt; k++){
                    int z = node[k];
                    if(mp.count(mkp(v,z)) && mp.count(mkp(u,z))){
                        edgecnt[mp[mkp(v,z)]]++;
                        edgecnt[mp[mkp(u,z)]]++;
                        edgecnt[mp[mkp(u,v)]]++;
                    }
                }
            }
        }
        ll ans = 0;
        for(int i=0;i<m; i++){
            ll c = edgecnt[i];
            ans += c*(c-1)/2;
        }
        cout<<ans<<endl;
    }
}

```