---
title: 组合博弈与SG函数
date: 2017-04-03 14:04:03
tags: [博弈论]
categories: ACM
---

## 组合博弈

### 组合博弈的规则（Imaprtial Combinatorial Games）
 1. 有两名选手  
 2. 两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动
 3. 对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； 
 4. 如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。

### 对NP状态的定义
1. 无法进行任何移动的局面（也就是terminal position）是P-position；
2. 可以移动到P-position的局面是N-position；
3. 所有移动都导致N-position的局面是P-position。

## SG函数

### mex运算
首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。

### SG 函数的定义
对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。


### 分析
来看一下SG函数的性质。首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。然后对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。  

以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了

我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。

### 证明

根据上述定义只需要证明SG值为0和不为0时满足P态和N态的性质即可  
1. 集合为空的时候不存在后继集合，SG值为0
2. 当g(G)=g(G1)^g(G2)^...^g(Gn)=k 时，必存在g(Gk)，有g(Gk)^k < g(Gk)从而存在对第k个子游戏的一种操作，使g(Gk)'=g(Gk)^k 从而g(G)' = 0
3. 当g(G)=g(G1)^g(G2)^...^g(Gn)=0时对任意一个子游戏进行操作必得到g(Gk)'<g(Gk)，从而g(G)'!=0 为N态，故g(G)=0时为P态

![](/images/还有这种操作.jpg)

### SG函数的应用
一个组合博弈分为N个子博弈，组合博弈的SG函数值就是子博弈SG函数值的异或。
在前面的Nim游戏当中，N个堆的分别的SG值就是当前堆的石子数（可以一次性全部取完）

#### 关于怎么去求SG函数的值   
根据定义我们知道求SG函数的值有几个关键的点：
1. 求当前状态的所有后缀状态的SG值
2. 对所有后缀的SG值进行Mes操作

因此，我们需要从终态状态开始，逐个求SG值，这就要求把局面转化为一个现态到终态递减的值或者在求SG值的时候注意安排现态在所有次态求出后  
对于Mes操作，先记录每一个后缀状态SG值的出现状况，然后找出第一个未出现的值即可  
可以用以下代码表示
```c++
//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理  
//SG[]:0~n的SG函数值  
//S[]:为x后继状态的集合  
int f[N],SG[MAXN],S[MAXN];  
void  getSG(int n){  
    int i,j;  
    memset(SG,0,sizeof(SG));  
    //因为SG[0]始终等于0，所以i从1开始  
    for(i = 1; i <= n; i++){  
        //每一次都要将上一状态 的 后继集合 重置  
        memset(S,0,sizeof(S));  
        for(j = 0; f[j] <= i && j <= N; j++)  
            S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记  
        for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值  
            SG[i] = j;  
            break;  
        }  
    }  
}  
```

对于有一类题SG函数值是存在规律的，对于输入量明显较大的题，可以先打个表找出SG函数的规律，对于另外一种
就需要把整个SG函数表保存起来

参考资料：
http://www.wutianqi.com/?p=1081