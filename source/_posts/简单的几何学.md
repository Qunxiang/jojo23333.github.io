---
title: 简单的几何学...
date: 2017-09-02 11:24:55
tags: [计算几何]
categories: ACM
---
题源：Central Europe Contest 2015 Zagreb H   
其实是道很无聊的题目了，就求交点判情况有点麻烦..  
用向量判交点然后手撕一下
```c++
struct Cvector{
    double x,y;
    Cvector(){}
    Cvector(double xx,double yy):x(xx),y(yy){}
}node[4];

struct Cline{
    Cvector a,b;
};

Cvector operator-(const Cvector &a,const Cvector &b){return Cvector(a.x-b.x,a.y-b.y);}
Cvector operator*(double k, const Cvector &a)       {return Cvector(k*a.x,k*a.y);}
Cvector operator+(const Cvector &a,const Cvector &b){return Cvector(a.x+b.x,a.y+b.y);}
double operator*(const Cvector &a,const Cvector &b) {return a.x*b.x+a.y*b.y;}
double operator^(const Cvector &a,const Cvector &b) {return a.x*b.y-a.y*b.x;}
double area(Cvector a,Cvector b){
    return (a^b)/2;
}

Cvector intersect(Cline l,Cline m,int &msg){
    double x = area(m.a-l.a, l.b-l.a);
    double y = area(l.b-l.a, m.b-l.a);
    if(x+y==0){
        msg = 1;//平行或者重合
        return Cvector(NaN,NaN);
    }
    return m.a+((x/(x+y))*(m.b-m.a));
}

Cline l[4];
double caly(Cline cl,double X)
{
    Cvector cross[4];
    Cvector point[2];
    int pcnt = 0,msg;
    for(int i=0; i<4; i++)
        cross[i] = intersect(cl,l[i],msg);
    for(int i=0; i<4; i++){
        if(cross[i].x >= l[i].a.x && cross[i].x <= l[i].b.x)
            point[pcnt++] = cross[i];
        else if(cross[i].x <= l[i].a.x && cross[i].x >= l[i].b.x)
            point[pcnt++] = cross[i];
    }
    int nodecnt = 0;
    double ans = 0;
    for(int i=0; i<4; i++)
        if(node[i].x<X)
            nodecnt++;
    if(nodecnt==3){
        for(int i=0; i<4; i++)
            if(node[i].x>=X)
                ans += abs((point[1]-node[i])^(point[0]-node[i]))/2;
        ans = 5.0*5.0-ans;
    }
    else for(int i=0; i<4; i++){
        if(node[i].x<X)
            ans += abs((point[1]-node[i])^(point[0]-node[i]))/2;
    }
    cout<<ans<<endl;
    return ans;
}

double calx(Cline cl,double Y)
{
    Cvector cross[4];
    Cvector point[2];
    int pcnt = 0,msg;
    for(int i=0; i<4; i++)
        cross[i] = intersect(cl,l[i],msg);
    for(int i=0; i<4; i++){
        if(cross[i].x >= l[i].a.x && cross[i].x <= l[i].b.x)
            point[pcnt++] = cross[i];
        else if(cross[i].x <= l[i].a.x && cross[i].x >= l[i].b.x)
            point[pcnt++] = cross[i];
    }
    double ans = 0;
    int nodecnt = 0;
    for(int i=0; i<4; i++)
        if(node[i].y<Y)
            nodecnt++;
    if(nodecnt==3){
        for(int i=0; i<4; i++)
            if(node[i].y>=Y)
                ans += abs((point[1]-node[i])^(point[0]-node[i]))/2;
        ans = 5.0*5.0-ans;
    }
    else for(int i=0; i<4; i++){
        if(node[i].y<Y)
            ans += abs((point[1]-node[i])^(point[0]-node[i]))/2;
    }
    cout<<ans<<endl;
    return ans;
}


int main()
{
    for(int i=0; i<4; i++){
        double x,y;
        scanf("%lf%lf",&x,&y);
        node[i].x =x;   node[i].y  = y;
    }
    for(int i=0; i<3; i++){
        l[i].a = node[i];   l[i].b = node[i+1];
    }
    l[3].a = node[3];   l[3].b = node[0];

    double ans = 0;
    Cline cl;
    cl.a = Cvector(0.5,0.5);    cl.b = Cvector(0.5,-0.5);
    ans += 3.0*(25.0-caly(cl,0.5));
    cl.a = Cvector(0.5,-0.5);    cl.b = Cvector(-0.5,-0.5);
    ans += 1.0*(calx(cl,-0.5));
    cl.a = Cvector(-0.5,-0.5);    cl.b = Cvector(-0.5,0.5);
    ans += 4.0*caly(cl,-0.5);
    cl.a = Cvector(-0.5,0.5);    cl.b = Cvector(0.5,0.5);
    ans += 6.0*(25.0-calx(cl,0.5));
    ans *= 5;
    ans += 5.0*5.0*5.0*4;
    ans /= (5.0*5.0*5.0-1.0);
    printf("%.6f\n",ans);
}

```
