{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/cat.jpg","path":"images/cat.jpg","modified":0,"renderable":0},{"_id":"source/images/还有这种操作.jpg","path":"images/还有这种操作.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1489292456000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1489292456000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1489292456000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1489292456000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1489292456000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1489292456000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1489292456000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1489292456000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1489292456000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1489292456000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1489292456000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1489292456000},{"_id":"themes/next/_config.yml","hash":"584fedc61b88f6db0dc4a9d10322e47b90a8b10b","modified":1489297002000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1489292456000},{"_id":"themes/next/gulpfile.coffee","hash":"933e6d29eb82522cff0df209d52b935e91b1111c","modified":1489292456000},{"_id":"themes/next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1489292456000},{"_id":"source/_posts/asm-learning-note.md","hash":"d13ec6de614e4a20d9f72ad6190da1b0ffb97d59","modified":1489630234000},{"_id":"source/_posts/三葉.md","hash":"d5d1a29de36dcba59d637b0e0e9e9b1e0eccd3a3","modified":1490377694000},{"_id":"source/categories/index.md","hash":"7df1224b40bd393538d461e23f0ddd853cf703d8","modified":1490377694000},{"_id":"source/images/cat.jpg","hash":"f176643ddfdf4a88010ab4032ba8ac447ef6a337","modified":1490377694000},{"_id":"source/images/还有这种操作.jpg","hash":"1520f5032d98d2896b081a6e47547b6f9a45c4b7","modified":1491202126000},{"_id":"source/tags/index.md","hash":"84362fc5d5b93b26b808ddfca97d0e2d039548c2","modified":1490377694000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1489292456000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1489292456000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1489292456000},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1489292456000},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1489292456000},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1489292456000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1489292456000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1489292456000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1489292456000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1489292456000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1489292456000},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1489292456000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1489292456000},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1489292456000},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1489292456000},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1489292456000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1489292456000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1489292456000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1489292456000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1489292456000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1489292456000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1489292456000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1489292456000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1489292456000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1489292456000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1489292458000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1489292458000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1489292458000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"source/_posts/acm/DP-最长上升子序列.md","hash":"3231caced020ca82344bccdedfc2400cf26a03a6","modified":1491934128000},{"_id":"source/_posts/acm/HDU-5667.md","hash":"d7c21e46a1fc564c1670fd3fbe6e35e085ca25b1","modified":1490353282000},{"_id":"source/_posts/acm/poj-1061.md","hash":"b8dc345953d253ccdfa08fee3402a74c2b9da9c7","modified":1490377694000},{"_id":"source/_posts/acm/poj-2348.md","hash":"3152a2028bd07876e8f28bc287641636d70e8fec","modified":1491306164000},{"_id":"source/_posts/acm/博弈论入门.md","hash":"436738bb1d6b8c9b4c2a52fc50a97f6e506939bc","modified":1491201954000},{"_id":"source/_posts/acm/组合博弈与SG函数.md","hash":"c38f70d0a53c087ec963cb6e0eb62d608ed7657d","modified":1491204602000},{"_id":"source/_posts/algorithms/图网络分析方法.md","hash":"53d71e46aef5039b9aefece046200d517e5d66d7","modified":1490377694000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1489292456000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1489292456000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1489292456000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1489292456000},{"_id":"themes/next/layout/_macro/post.swig","hash":"4a191a612383bb04a4705b4044c033f765060207","modified":1489292456000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1489292456000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1489292456000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1489292456000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1489292456000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1489292456000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1489292456000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1489292456000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1489292456000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1489292456000},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1489292456000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1489292456000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1489292456000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1489292456000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1489292456000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1489292456000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1489292456000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1489292456000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1489292456000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1489292456000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1489292456000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1489292456000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1489292456000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1489292456000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1489292456000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1489292456000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1489292456000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1489292456000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1489292456000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1489292456000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1489292456000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489292456000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1489292456000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1489292456000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1489292456000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1489292456000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1489292456000},{"_id":"source/_posts/acm/match/2017-广西邀请赛.md","hash":"e25cf20fcfa408e0775df33e6b2a50ecae56b81f","modified":1503826355818},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1489292456000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1489292456000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1489292456000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1489292456000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"2d1075f4cabcb3956b7b84a8e210f5a66f0a5562","modified":1489292456000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1489292456000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1489292456000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1489292456000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1489292456000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1489292456000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1489292456000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1489292456000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"f4dbd4c896e6510ded8ebe05394c28f8a86e71bf","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1489292456000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1489292456000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1489292456000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1489292456000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1489292456000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1489292456000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7c76d93605e2b685274400afe51c55cc651486e","modified":1489292456000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1489292456000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1489292458000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1489292458000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1489292458000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1489292458000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1489292458000},{"_id":"themes/next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1489292458000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1489292458000},{"_id":"themes/next/source/js/src/utils.js","hash":"e13c9ccf70d593bdf3b8cc1d768f595abd610e6e","modified":1489292458000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1489292458000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1489292458000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1489292458000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1489292458000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1489292458000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1489292458000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1489292458000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1489292458000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1489292458000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1489292458000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1489292458000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1489292458000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1489292458000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1489292458000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1489292458000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1489292458000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1489292458000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1489292458000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1489292458000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1489292456000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1489292456000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1489292456000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1489292456000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1489292456000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1489292456000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1489292456000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1489292456000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1489292458000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1489292458000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1489292458000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1489292458000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1489292458000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1489292458000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1489292456000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1489292456000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1489292456000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489292458000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1489292458000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1489292458000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1489292458000},{"_id":"source/_posts/acm/markdown/博弈论入门.md","hash":"436738bb1d6b8c9b4c2a52fc50a97f6e506939bc","modified":1491201954000},{"_id":"source/_posts/acm/题解/DP-最长上升子序列.md","hash":"3231caced020ca82344bccdedfc2400cf26a03a6","modified":1491934128000},{"_id":"source/_posts/acm/题解/poj-1061.md","hash":"b8dc345953d253ccdfa08fee3402a74c2b9da9c7","modified":1490377694000},{"_id":"source/_posts/acm/题解/poj-2348.md","hash":"3152a2028bd07876e8f28bc287641636d70e8fec","modified":1491306164000},{"_id":"source/_posts/acm/题解/HDU-5667.md","hash":"d7c21e46a1fc564c1670fd3fbe6e35e085ca25b1","modified":1490353282000},{"_id":"source/_posts/acm/题解/组合博弈与SG函数.md","hash":"c38f70d0a53c087ec963cb6e0eb62d608ed7657d","modified":1491204602000},{"_id":"source/_posts/acm/markdown/math/有关异或运算.md","hash":"5cd6be5462e123cd085fb4fb3c2ab40cbb5183f3","modified":1503834233003},{"_id":"source/_posts/acm/markdown/math/欧拉函数.md","hash":"c2d63763bd24e391a74f54ca432c23769d13e122","modified":1503834147120},{"_id":"source/_posts/acm/markdown/math/素数线性筛法.md","hash":"e387d2f0b728c1ae2d91d1957aff46673a972631","modified":1503834191635},{"_id":"source/_posts/acm/markdown/图论/二分图.md","hash":"0e29ee6b8e9ae253b13631bd35744c24598994ec","modified":1503834396470},{"_id":"source/_posts/acm/markdown/图论/二分图.png","hash":"a9fc547c4a7811a9f0a48c2d3ae14e2909e85511","modified":1503411250315},{"_id":"source/_posts/acm/markdown/数据结构/稀疏表.md","hash":"c21cf348e86cdf4c56671e83358e4f84a8b85ac9","modified":1503834269254},{"_id":"source/_posts/acm/题解/图论/Uva-11354 最小瓶颈树+LCA倍增法维护最大值.md","hash":"7e5d0df1686ee3b37ef9a4ab00bd525a87b99334","modified":1503834581572},{"_id":"source/_posts/acm/题解/图论/二分图/Uva-14149 二分图匹配求最小点覆盖.md","hash":"4a04b0a3984ccd2f5690bd3b6acb22fe7fd28243","modified":1503834640335}],"Category":[{"name":"说说","_id":"cj6ujd9lh0004b8woi1qjgrd9"},{"name":"ACM","_id":"cj6ujd9y6000ab8wofplz8vz4"},{"name":"算法","_id":"cj6ujda0q000pb8wo0ow03jeg"}],"Data":[],"Page":[{"title":"categories","date":"2017-03-12T04:54:02.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-03-12 12:54:02\ntype: \"categories\"\n---\n","updated":"2017-03-24T17:48:14.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj6ujd9kh0001b8wo310kxwvv","content":"","excerpt":"","more":""},{"title":"tags","date":"2017-03-12T04:47:58.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-03-12 12:47:58\ntype: \"tags\"\n---\n","updated":"2017-03-24T17:48:14.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj6ujd9l50003b8woqvtdm0a1","content":"","excerpt":"","more":""}],"Post":[{"title":"asm_learning_note","date":"2017-03-16T02:10:32.000Z","_content":"","source":"_posts/asm-learning-note.md","raw":"---\ntitle: asm_learning_note\ndate: 2017-03-16 10:10:32\ntags:\n---\n","slug":"asm-learning-note","published":1,"updated":"2017-03-16T02:10:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6ujd9jx0000b8wo6kc4xjws","content":"","excerpt":"","more":""},{"title":"三葉のテーマ","date":"2017-03-15T15:53:53.000Z","_content":"   会困扰吗，会尴尬吗，还是...会有些许的高兴呢..  \n\n\n   回忆中，三叶一个人踏上去东京的电车时候，到底是怎样一种心情呢  \n\n\n   最喜欢的一首 \n\n   \n","source":"_posts/三葉.md","raw":"---\ntitle: 三葉のテーマ\ndate: 2017-03-15 23:53:53\ncategories: 说说\ntags: 随想\n---\n   会困扰吗，会尴尬吗，还是...会有些许的高兴呢..  \n\n\n   回忆中，三叶一个人踏上去东京的电车时候，到底是怎样一种心情呢  \n\n\n   最喜欢的一首 \n\n   \n","slug":"三葉","published":1,"updated":"2017-03-24T17:48:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6ujd9kp0002b8wowoxx45nv","content":"<p>   会困扰吗，会尴尬吗，还是…会有些许的高兴呢..  </p>\n<p>   回忆中，三叶一个人踏上去东京的电车时候，到底是怎样一种心情呢  </p>\n<p>   最喜欢的一首 </p>\n","excerpt":"","more":"<p>   会困扰吗，会尴尬吗，还是…会有些许的高兴呢..  </p>\n<p>   回忆中，三叶一个人踏上去东京的电车时候，到底是怎样一种心情呢  </p>\n<p>   最喜欢的一首 </p>\n"},{"title":"图网络分析方法","date":"2017-03-09T13:54:00.000Z","_content":"\n## 前言\n不是什么事情都要给别人一个交代，但总是要给自己一个交代的，因此遍有了这一篇总结。   \n\n 这是一篇来自于课程设计的markdown，由于自己给自己开的坑，花费了大量时间。\n还有一个目的主要是记录下自己学到的知识，以方便以这段经历为跳板，在后面对数据挖掘领域进行更深层次的学习\n\n## 图网络分析方法的主要任务\n\n### 引出\n\n对于一般的图结构的数据来说，抛开节点和边所带的附加数据域来看，图的主要性质，就体现在节点 边的属性和图本身的拓扑结构上了  比如说节点的度 边的权 都是表征图结构基本而又重要的性质.   \n不过对于这些性质来说，还是从微观在描述图的最小成员：节点和边在图拓扑中的性质，因此要描述整个图结构的性质，就需要有另外一些衡量标准与方法  \n\n### 网络性质 NetworkOverview\n这里取图可视化软件**Gephi**的所选取的几个指标：  \n1. Network Diameter 网络直径 \n2. Graph Density 图紧密度\n3. Modularity 模块度\n4. Centrarity 中心度 \n5. Connected subgraph 联通子图 \n\n\n## 网络分析的主要算法\n\n 这里只列举几个我实际学习并实现的 \n\n### PageRank（Centrarity ）-2002\n PageRank 是很为我们熟知的google发家的算法，网络拓扑其实也就是一个很大型的图结构。关于PageRank 的介绍网上已经有较为详细的解读了，[这篇blog写得挺好](http://blog.jobbole.com/71431/)。\n\nPageRank 其实从算法原理上非常简单，就是一个矩阵的迭代，实际应用中真正的问题在于大型网络拓扑的分布式计算 因而有了PageRank的mapreduce实现\n\n\n### 顶点度（Centrarity ）\n ..大家什么都没看到\n\n### Gravian-Newman 社区发现算法（Modularity） -2004\n 社区发现的入门级算法...折腾了我好久  \n 这个我感觉网上现有的一些资料中并没有很好的..我会自己写一篇详细介绍的   \n 附上链接 **[Newman教授的个人主页](http://www-personal.umich.edu/~mejn/)**\n\n\n### FastUnfolding 算法 （Modularity）-2008\n 同样会另起一篇blog介绍这个..但感觉自己对这个算法理解的还不是那么透彻..特别是在模块度的计算上还有些问题..在这里mark住，以便以后继续学习\n\n\n","source":"_posts/algorithms/图网络分析方法.md","raw":"---\ntitle: 图网络分析方法  \ndate: 2017-03-09 21:54:00  \ncategories: 算法\ntags:  [数据挖掘,图] \n---\n\n## 前言\n不是什么事情都要给别人一个交代，但总是要给自己一个交代的，因此遍有了这一篇总结。   \n\n 这是一篇来自于课程设计的markdown，由于自己给自己开的坑，花费了大量时间。\n还有一个目的主要是记录下自己学到的知识，以方便以这段经历为跳板，在后面对数据挖掘领域进行更深层次的学习\n\n## 图网络分析方法的主要任务\n\n### 引出\n\n对于一般的图结构的数据来说，抛开节点和边所带的附加数据域来看，图的主要性质，就体现在节点 边的属性和图本身的拓扑结构上了  比如说节点的度 边的权 都是表征图结构基本而又重要的性质.   \n不过对于这些性质来说，还是从微观在描述图的最小成员：节点和边在图拓扑中的性质，因此要描述整个图结构的性质，就需要有另外一些衡量标准与方法  \n\n### 网络性质 NetworkOverview\n这里取图可视化软件**Gephi**的所选取的几个指标：  \n1. Network Diameter 网络直径 \n2. Graph Density 图紧密度\n3. Modularity 模块度\n4. Centrarity 中心度 \n5. Connected subgraph 联通子图 \n\n\n## 网络分析的主要算法\n\n 这里只列举几个我实际学习并实现的 \n\n### PageRank（Centrarity ）-2002\n PageRank 是很为我们熟知的google发家的算法，网络拓扑其实也就是一个很大型的图结构。关于PageRank 的介绍网上已经有较为详细的解读了，[这篇blog写得挺好](http://blog.jobbole.com/71431/)。\n\nPageRank 其实从算法原理上非常简单，就是一个矩阵的迭代，实际应用中真正的问题在于大型网络拓扑的分布式计算 因而有了PageRank的mapreduce实现\n\n\n### 顶点度（Centrarity ）\n ..大家什么都没看到\n\n### Gravian-Newman 社区发现算法（Modularity） -2004\n 社区发现的入门级算法...折腾了我好久  \n 这个我感觉网上现有的一些资料中并没有很好的..我会自己写一篇详细介绍的   \n 附上链接 **[Newman教授的个人主页](http://www-personal.umich.edu/~mejn/)**\n\n\n### FastUnfolding 算法 （Modularity）-2008\n 同样会另起一篇blog介绍这个..但感觉自己对这个算法理解的还不是那么透彻..特别是在模块度的计算上还有些问题..在这里mark住，以便以后继续学习\n\n\n","slug":"algorithms/图网络分析方法","published":1,"updated":"2017-03-24T17:48:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6ujda0e000kb8wo3d863rzs","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不是什么事情都要给别人一个交代，但总是要给自己一个交代的，因此遍有了这一篇总结。   </p>\n<p> 这是一篇来自于课程设计的markdown，由于自己给自己开的坑，花费了大量时间。<br>还有一个目的主要是记录下自己学到的知识，以方便以这段经历为跳板，在后面对数据挖掘领域进行更深层次的学习</p>\n<h2 id=\"图网络分析方法的主要任务\"><a href=\"#图网络分析方法的主要任务\" class=\"headerlink\" title=\"图网络分析方法的主要任务\"></a>图网络分析方法的主要任务</h2><h3 id=\"引出\"><a href=\"#引出\" class=\"headerlink\" title=\"引出\"></a>引出</h3><p>对于一般的图结构的数据来说，抛开节点和边所带的附加数据域来看，图的主要性质，就体现在节点 边的属性和图本身的拓扑结构上了  比如说节点的度 边的权 都是表征图结构基本而又重要的性质.<br>不过对于这些性质来说，还是从微观在描述图的最小成员：节点和边在图拓扑中的性质，因此要描述整个图结构的性质，就需要有另外一些衡量标准与方法  </p>\n<h3 id=\"网络性质-NetworkOverview\"><a href=\"#网络性质-NetworkOverview\" class=\"headerlink\" title=\"网络性质 NetworkOverview\"></a>网络性质 NetworkOverview</h3><p>这里取图可视化软件<strong>Gephi</strong>的所选取的几个指标：  </p>\n<ol>\n<li>Network Diameter 网络直径 </li>\n<li>Graph Density 图紧密度</li>\n<li>Modularity 模块度</li>\n<li>Centrarity 中心度 </li>\n<li>Connected subgraph 联通子图 </li>\n</ol>\n<h2 id=\"网络分析的主要算法\"><a href=\"#网络分析的主要算法\" class=\"headerlink\" title=\"网络分析的主要算法\"></a>网络分析的主要算法</h2><p> 这里只列举几个我实际学习并实现的 </p>\n<h3 id=\"PageRank（Centrarity-）-2002\"><a href=\"#PageRank（Centrarity-）-2002\" class=\"headerlink\" title=\"PageRank（Centrarity ）-2002\"></a>PageRank（Centrarity ）-2002</h3><p> PageRank 是很为我们熟知的google发家的算法，网络拓扑其实也就是一个很大型的图结构。关于PageRank 的介绍网上已经有较为详细的解读了，<a href=\"http://blog.jobbole.com/71431/\" target=\"_blank\" rel=\"external\">这篇blog写得挺好</a>。</p>\n<p>PageRank 其实从算法原理上非常简单，就是一个矩阵的迭代，实际应用中真正的问题在于大型网络拓扑的分布式计算 因而有了PageRank的mapreduce实现</p>\n<h3 id=\"顶点度（Centrarity-）\"><a href=\"#顶点度（Centrarity-）\" class=\"headerlink\" title=\"顶点度（Centrarity ）\"></a>顶点度（Centrarity ）</h3><p> ..大家什么都没看到</p>\n<h3 id=\"Gravian-Newman-社区发现算法（Modularity）-2004\"><a href=\"#Gravian-Newman-社区发现算法（Modularity）-2004\" class=\"headerlink\" title=\"Gravian-Newman 社区发现算法（Modularity） -2004\"></a>Gravian-Newman 社区发现算法（Modularity） -2004</h3><p> 社区发现的入门级算法…折腾了我好久<br> 这个我感觉网上现有的一些资料中并没有很好的..我会自己写一篇详细介绍的<br> 附上链接 <strong><a href=\"http://www-personal.umich.edu/~mejn/\" target=\"_blank\" rel=\"external\">Newman教授的个人主页</a></strong></p>\n<h3 id=\"FastUnfolding-算法-（Modularity）-2008\"><a href=\"#FastUnfolding-算法-（Modularity）-2008\" class=\"headerlink\" title=\"FastUnfolding 算法 （Modularity）-2008\"></a>FastUnfolding 算法 （Modularity）-2008</h3><p> 同样会另起一篇blog介绍这个..但感觉自己对这个算法理解的还不是那么透彻..特别是在模块度的计算上还有些问题..在这里mark住，以便以后继续学习</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不是什么事情都要给别人一个交代，但总是要给自己一个交代的，因此遍有了这一篇总结。   </p>\n<p> 这是一篇来自于课程设计的markdown，由于自己给自己开的坑，花费了大量时间。<br>还有一个目的主要是记录下自己学到的知识，以方便以这段经历为跳板，在后面对数据挖掘领域进行更深层次的学习</p>\n<h2 id=\"图网络分析方法的主要任务\"><a href=\"#图网络分析方法的主要任务\" class=\"headerlink\" title=\"图网络分析方法的主要任务\"></a>图网络分析方法的主要任务</h2><h3 id=\"引出\"><a href=\"#引出\" class=\"headerlink\" title=\"引出\"></a>引出</h3><p>对于一般的图结构的数据来说，抛开节点和边所带的附加数据域来看，图的主要性质，就体现在节点 边的属性和图本身的拓扑结构上了  比如说节点的度 边的权 都是表征图结构基本而又重要的性质.<br>不过对于这些性质来说，还是从微观在描述图的最小成员：节点和边在图拓扑中的性质，因此要描述整个图结构的性质，就需要有另外一些衡量标准与方法  </p>\n<h3 id=\"网络性质-NetworkOverview\"><a href=\"#网络性质-NetworkOverview\" class=\"headerlink\" title=\"网络性质 NetworkOverview\"></a>网络性质 NetworkOverview</h3><p>这里取图可视化软件<strong>Gephi</strong>的所选取的几个指标：  </p>\n<ol>\n<li>Network Diameter 网络直径 </li>\n<li>Graph Density 图紧密度</li>\n<li>Modularity 模块度</li>\n<li>Centrarity 中心度 </li>\n<li>Connected subgraph 联通子图 </li>\n</ol>\n<h2 id=\"网络分析的主要算法\"><a href=\"#网络分析的主要算法\" class=\"headerlink\" title=\"网络分析的主要算法\"></a>网络分析的主要算法</h2><p> 这里只列举几个我实际学习并实现的 </p>\n<h3 id=\"PageRank（Centrarity-）-2002\"><a href=\"#PageRank（Centrarity-）-2002\" class=\"headerlink\" title=\"PageRank（Centrarity ）-2002\"></a>PageRank（Centrarity ）-2002</h3><p> PageRank 是很为我们熟知的google发家的算法，网络拓扑其实也就是一个很大型的图结构。关于PageRank 的介绍网上已经有较为详细的解读了，<a href=\"http://blog.jobbole.com/71431/\">这篇blog写得挺好</a>。</p>\n<p>PageRank 其实从算法原理上非常简单，就是一个矩阵的迭代，实际应用中真正的问题在于大型网络拓扑的分布式计算 因而有了PageRank的mapreduce实现</p>\n<h3 id=\"顶点度（Centrarity-）\"><a href=\"#顶点度（Centrarity-）\" class=\"headerlink\" title=\"顶点度（Centrarity ）\"></a>顶点度（Centrarity ）</h3><p> ..大家什么都没看到</p>\n<h3 id=\"Gravian-Newman-社区发现算法（Modularity）-2004\"><a href=\"#Gravian-Newman-社区发现算法（Modularity）-2004\" class=\"headerlink\" title=\"Gravian-Newman 社区发现算法（Modularity） -2004\"></a>Gravian-Newman 社区发现算法（Modularity） -2004</h3><p> 社区发现的入门级算法…折腾了我好久<br> 这个我感觉网上现有的一些资料中并没有很好的..我会自己写一篇详细介绍的<br> 附上链接 <strong><a href=\"http://www-personal.umich.edu/~mejn/\">Newman教授的个人主页</a></strong></p>\n<h3 id=\"FastUnfolding-算法-（Modularity）-2008\"><a href=\"#FastUnfolding-算法-（Modularity）-2008\" class=\"headerlink\" title=\"FastUnfolding 算法 （Modularity）-2008\"></a>FastUnfolding 算法 （Modularity）-2008</h3><p> 同样会另起一篇blog介绍这个..但感觉自己对这个算法理解的还不是那么透彻..特别是在模块度的计算上还有些问题..在这里mark住，以便以后继续学习</p>\n"},{"title":"2017-广西邀请赛","date":"2017-08-27T09:25:04.000Z","_content":"算是我队第一次打正式赛了吧..全场贡献了几题思路..打表大法是真的强..  \n终榜5题银..还行..\n\n### 记录几个要补的题：   \n1. C: 怎么求三元环\n2. G: 平面图转对偶图\n3. K： 暴力哈希KMP\n","source":"_posts/acm/match/2017-广西邀请赛.md","raw":"---\ntitle: 2017-广西邀请赛\ndate: 2017-08-27 17:25:04\ntags: [比赛,题解,三元环]\ncategories: ACM\n---\n算是我队第一次打正式赛了吧..全场贡献了几题思路..打表大法是真的强..  \n终榜5题银..还行..\n\n### 记录几个要补的题：   \n1. C: 怎么求三元环\n2. G: 平面图转对偶图\n3. K： 暴力哈希KMP\n","slug":"acm/match/2017-广西邀请赛","published":1,"updated":"2017-08-27T09:32:35.818Z","_id":"cj6ujda6q001cb8woqsnbn0hq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>算是我队第一次打正式赛了吧..全场贡献了几题思路..打表大法是真的强..<br>终榜5题银..还行..</p>\n<h3 id=\"记录几个要补的题：\"><a href=\"#记录几个要补的题：\" class=\"headerlink\" title=\"记录几个要补的题：\"></a>记录几个要补的题：</h3><ol>\n<li>C: 怎么求三元环</li>\n<li>G: 平面图转对偶图</li>\n<li>K： 暴力哈希KMP</li>\n</ol>\n","excerpt":"","more":"<p>算是我队第一次打正式赛了吧..全场贡献了几题思路..打表大法是真的强..<br>终榜5题银..还行..</p>\n<h3 id=\"记录几个要补的题：\"><a href=\"#记录几个要补的题：\" class=\"headerlink\" title=\"记录几个要补的题：\"></a>记录几个要补的题：</h3><ol>\n<li>C: 怎么求三元环</li>\n<li>G: 平面图转对偶图</li>\n<li>K： 暴力哈希KMP</li>\n</ol>\n"},{"title":"博弈论入门","date":"2017-03-30T09:42:14.000Z","_content":"## 几种博弈：\n### 巴什博奕（Bash Game）\n*只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜*\n\n### 威佐夫博奕（Wythoff Game） \n*有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。*\n\n那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：\n\n    ak =[k（1+√5）/2]，bk= ak + k  （k=0，1，2，…,n 方括号表示取整函数) \n\n可以这样进行判断：\n``` c++\n\tint a = max(M,N);\t//M,N分别为一开始两堆物品个数\n\tint b = min(M,N);\n\tint k = a-b;\n\ta = int(k*(1+sqrt(5))/2.0);\n\tif(a==b)\n\t\tflag = false;\t//先手必败 P态\n\telse\n\t\tflag = true;\t//先手必胜 N态\n```\n\n**威佐夫游戏的一种变形：** 见 POJ2348\n\n\n### Nim游戏\n有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。\n\nNim 游戏是组合游戏的一种\n当每堆物品分别为a1 a2 a3...an时  \n若a1^a2^a3^...an == 0时则为必败态，反之必胜\n\n","source":"_posts/acm/markdown/博弈论入门.md","raw":"---\ntitle: 博弈论入门\ndate: 2017-03-30 17:42:14\ntags: [博弈论]\ncategories: ACM\n---\n## 几种博弈：\n### 巴什博奕（Bash Game）\n*只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜*\n\n### 威佐夫博奕（Wythoff Game） \n*有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。*\n\n那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：\n\n    ak =[k（1+√5）/2]，bk= ak + k  （k=0，1，2，…,n 方括号表示取整函数) \n\n可以这样进行判断：\n``` c++\n\tint a = max(M,N);\t//M,N分别为一开始两堆物品个数\n\tint b = min(M,N);\n\tint k = a-b;\n\ta = int(k*(1+sqrt(5))/2.0);\n\tif(a==b)\n\t\tflag = false;\t//先手必败 P态\n\telse\n\t\tflag = true;\t//先手必胜 N态\n```\n\n**威佐夫游戏的一种变形：** 见 POJ2348\n\n\n### Nim游戏\n有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。\n\nNim 游戏是组合游戏的一种\n当每堆物品分别为a1 a2 a3...an时  \n若a1^a2^a3^...an == 0时则为必败态，反之必胜\n\n","slug":"acm/markdown/博弈论入门","published":1,"updated":"2017-04-03T06:45:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecee0000uowo14cz3s7e","content":"<h2 id=\"几种博弈：\"><a href=\"#几种博弈：\" class=\"headerlink\" title=\"几种博弈：\"></a>几种博弈：</h2><h3 id=\"巴什博奕（Bash-Game）\"><a href=\"#巴什博奕（Bash-Game）\" class=\"headerlink\" title=\"巴什博奕（Bash Game）\"></a>巴什博奕（Bash Game）</h3><p><em>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜</em></p>\n<h3 id=\"威佐夫博奕（Wythoff-Game）\"><a href=\"#威佐夫博奕（Wythoff-Game）\" class=\"headerlink\" title=\"威佐夫博奕（Wythoff Game）\"></a>威佐夫博奕（Wythoff Game）</h3><p><em>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</em></p>\n<p>那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：</p>\n<pre><code>ak =[k（1+√5）/2]，bk= ak + k  （k=0，1，2，…,n 方括号表示取整函数) \n</code></pre><p>可以这样进行判断：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = max(M,N);\t<span class=\"comment\">//M,N分别为一开始两堆物品个数</span></div><div class=\"line\"><span class=\"keyword\">int</span> b = min(M,N);</div><div class=\"line\"><span class=\"keyword\">int</span> k = a-b;</div><div class=\"line\">a = <span class=\"keyword\">int</span>(k*(<span class=\"number\">1</span>+<span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>))/<span class=\"number\">2.0</span>);</div><div class=\"line\"><span class=\"keyword\">if</span>(a==b)</div><div class=\"line\">\tflag = <span class=\"literal\">false</span>;\t<span class=\"comment\">//先手必败 P态</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\tflag = <span class=\"literal\">true</span>;\t<span class=\"comment\">//先手必胜 N态</span></div></pre></td></tr></table></figure></p>\n<p><strong>威佐夫游戏的一种变形：</strong> 见 POJ2348</p>\n<h3 id=\"Nim游戏\"><a href=\"#Nim游戏\" class=\"headerlink\" title=\"Nim游戏\"></a>Nim游戏</h3><p>有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>\n<p>Nim 游戏是组合游戏的一种<br>当每堆物品分别为a1 a2 a3…an时<br>若a1^a2^a3^…an == 0时则为必败态，反之必胜</p>\n","excerpt":"","more":"<h2 id=\"几种博弈：\"><a href=\"#几种博弈：\" class=\"headerlink\" title=\"几种博弈：\"></a>几种博弈：</h2><h3 id=\"巴什博奕（Bash-Game）\"><a href=\"#巴什博奕（Bash-Game）\" class=\"headerlink\" title=\"巴什博奕（Bash Game）\"></a>巴什博奕（Bash Game）</h3><p><em>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜</em></p>\n<h3 id=\"威佐夫博奕（Wythoff-Game）\"><a href=\"#威佐夫博奕（Wythoff-Game）\" class=\"headerlink\" title=\"威佐夫博奕（Wythoff Game）\"></a>威佐夫博奕（Wythoff Game）</h3><p><em>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</em></p>\n<p>那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：</p>\n<pre><code>ak =[k（1+√5）/2]，bk= ak + k  （k=0，1，2，…,n 方括号表示取整函数) \n</code></pre><p>可以这样进行判断：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = max(M,N);\t<span class=\"comment\">//M,N分别为一开始两堆物品个数</span></div><div class=\"line\"><span class=\"keyword\">int</span> b = min(M,N);</div><div class=\"line\"><span class=\"keyword\">int</span> k = a-b;</div><div class=\"line\">a = <span class=\"keyword\">int</span>(k*(<span class=\"number\">1</span>+<span class=\"built_in\">sqrt</span>(<span class=\"number\">5</span>))/<span class=\"number\">2.0</span>);</div><div class=\"line\"><span class=\"keyword\">if</span>(a==b)</div><div class=\"line\">\tflag = <span class=\"literal\">false</span>;\t<span class=\"comment\">//先手必败 P态</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\tflag = <span class=\"literal\">true</span>;\t<span class=\"comment\">//先手必胜 N态</span></div></pre></td></tr></table></figure></p>\n<p><strong>威佐夫游戏的一种变形：</strong> 见 POJ2348</p>\n<h3 id=\"Nim游戏\"><a href=\"#Nim游戏\" class=\"headerlink\" title=\"Nim游戏\"></a>Nim游戏</h3><p>有n堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p>\n<p>Nim 游戏是组合游戏的一种<br>当每堆物品分别为a1 a2 a3…an时<br>若a1^a2^a3^…an == 0时则为必败态，反之必胜</p>\n"},{"title":"DP-最长上升子序列","date":"2017-04-11T17:59:43.000Z","_content":"## 解析\n这个问题是DP问题中的一个经典模型，可以参考《挑战程序设计竞赛》P64  \n做了几道题由这个模型可以引申解决一些经典DP问题  \n\n## 例子\n\n## 总结\n最长上升子序列为模型的问题有的特点总结为：  \n1. 存在一个有序序列，或是，序列需要至少按照某种规则使之有序\n2. 状态转移由当前元素前面的元素决定，这是有序序列的特殊性质  \n  \n其状态转移方程大致格式为： DP[i] = max{DP[i],dp[j]+k[i]}  \n对于最长上升子序列问题 k[i]\t== 1","source":"_posts/acm/题解/DP-最长上升子序列.md","raw":"---\ntitle: DP-最长上升子序列\ndate: 2017-04-12 01:59:43\ntags: [动态规划]\ncategories: ACM\n---\n## 解析\n这个问题是DP问题中的一个经典模型，可以参考《挑战程序设计竞赛》P64  \n做了几道题由这个模型可以引申解决一些经典DP问题  \n\n## 例子\n\n## 总结\n最长上升子序列为模型的问题有的特点总结为：  \n1. 存在一个有序序列，或是，序列需要至少按照某种规则使之有序\n2. 状态转移由当前元素前面的元素决定，这是有序序列的特殊性质  \n  \n其状态转移方程大致格式为： DP[i] = max{DP[i],dp[j]+k[i]}  \n对于最长上升子序列问题 k[i]\t== 1","slug":"acm/题解/DP-最长上升子序列","published":1,"updated":"2017-04-11T18:08:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecex0001uowogvk75eve","content":"<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>这个问题是DP问题中的一个经典模型，可以参考《挑战程序设计竞赛》P64<br>做了几道题由这个模型可以引申解决一些经典DP问题  </p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最长上升子序列为模型的问题有的特点总结为：  </p>\n<ol>\n<li>存在一个有序序列，或是，序列需要至少按照某种规则使之有序</li>\n<li>状态转移由当前元素前面的元素决定，这是有序序列的特殊性质  </li>\n</ol>\n<p>其状态转移方程大致格式为： DP[i] = max{DP[i],dp[j]+k[i]}<br>对于最长上升子序列问题 k[i]    == 1</p>\n","excerpt":"","more":"<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>这个问题是DP问题中的一个经典模型，可以参考《挑战程序设计竞赛》P64<br>做了几道题由这个模型可以引申解决一些经典DP问题  </p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最长上升子序列为模型的问题有的特点总结为：  </p>\n<ol>\n<li>存在一个有序序列，或是，序列需要至少按照某种规则使之有序</li>\n<li>状态转移由当前元素前面的元素决定，这是有序序列的特殊性质  </li>\n</ol>\n<p>其状态转移方程大致格式为： DP[i] = max{DP[i],dp[j]+k[i]}<br>对于最长上升子序列问题 k[i]    == 1</p>\n"},{"title":"poj-1061 扩展欧几里得","date":"2017-03-12T16:03:34.000Z","_content":"\n## 扩展欧几里得\n第一次写扩展欧几里得，感觉最重要的还是最开始就搞懂定理的推导过程，不然会遇到一些坑，在这里简单的mark一下我的理解。 \n\n### 原理\n扩展欧几里得德递归形式和gcd类似，关键在于中途对x,y的处理，重点在理解一下方程的推导：   \n**ax1+by1=gcd(a,b)**  ....1  \n**bx2+ay2=gcd(b,a%b)**  ....2  \n**gcd(a,b)=gcd(b,a%b)**  ....3  \n\n化简可以得到：x1=y2 y1=x2-a/b*y2  之后便不难理解边界条件设为b=0时，最终可以推出来方程1的一组解x0,y0  \n  \n### 推论\n重点在于其得到的推论：**ax+by=c 仅当cMODgcd(a,b)=0 时有解**  \n设 c = k*gcd(a,b)  \n上式可以化简为 a/gcd(a,b)*x + b/gcd(a,b)*y = k   =>  Ax+By=k  \n显然AB互质，因而满足方程的解系为(x0-nB,x0+nA) n为任意整数  \n\n## 题解\n就这道题目来说，我觉得对新手来说坑还是有几个：  \n1. 将追逐问题转化为ax+by=c 的不定方程组的解的问题，即确定a和b.\n2. 将exgcd求得的解转化为原方程的解（判断是否有解），并最小化\n\n### 代码\n```c++\n#include <iostream>\n\n#define ABS(x) (((x)>0)?(x):(-(x)))\n#define LL long long\nusing namespace std;\n\n//ax+by = gcd(a,b)\nvoid exgcd(LL a,LL b,LL &x,LL &y,LL &d)\n{\n\tif(b==0){\n\t\tx = 1; y = 0; d =a;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y,d);\n\tLL t=x;\n\tx = y;\n\ty = t - (a/b)*y;\n\treturn;\n}\n\n\nint main()\n{\n\tLL x,y,m,n,l;\n\tcin>>x>>y>>m>>n>>l;\n\tLL v,dis,d,x0,y0;\n\tv  = ABS(m-n);\n\tif(m>n)\n\t\tdis = (y-x+l)%l;\n\telse\n\t\tdis = (x-y+l)%l;\n\t\t\n\texgcd(v,l,x0,y0,d);\n\t\n\tif(d&&dis%d==0){\n\t\tx0 = x0*dis/d;\n\t\tLL t = l/d;\n\t\tx0 = (x0%t+t)%t;\n\t\tcout<<x0<<endl;\n\t}\n\telse{\n\t\tcout<<\"Impossible\"<<endl;\n\t}\n}\n\n```\n","source":"_posts/acm/题解/poj-1061.md","raw":"---\ntitle: poj-1061 扩展欧几里得\ndate: 2017-03-13 00:03:34\ncategories: ACM\ntags:  [数论,题解]\n---\n\n## 扩展欧几里得\n第一次写扩展欧几里得，感觉最重要的还是最开始就搞懂定理的推导过程，不然会遇到一些坑，在这里简单的mark一下我的理解。 \n\n### 原理\n扩展欧几里得德递归形式和gcd类似，关键在于中途对x,y的处理，重点在理解一下方程的推导：   \n**ax1+by1=gcd(a,b)**  ....1  \n**bx2+ay2=gcd(b,a%b)**  ....2  \n**gcd(a,b)=gcd(b,a%b)**  ....3  \n\n化简可以得到：x1=y2 y1=x2-a/b*y2  之后便不难理解边界条件设为b=0时，最终可以推出来方程1的一组解x0,y0  \n  \n### 推论\n重点在于其得到的推论：**ax+by=c 仅当cMODgcd(a,b)=0 时有解**  \n设 c = k*gcd(a,b)  \n上式可以化简为 a/gcd(a,b)*x + b/gcd(a,b)*y = k   =>  Ax+By=k  \n显然AB互质，因而满足方程的解系为(x0-nB,x0+nA) n为任意整数  \n\n## 题解\n就这道题目来说，我觉得对新手来说坑还是有几个：  \n1. 将追逐问题转化为ax+by=c 的不定方程组的解的问题，即确定a和b.\n2. 将exgcd求得的解转化为原方程的解（判断是否有解），并最小化\n\n### 代码\n```c++\n#include <iostream>\n\n#define ABS(x) (((x)>0)?(x):(-(x)))\n#define LL long long\nusing namespace std;\n\n//ax+by = gcd(a,b)\nvoid exgcd(LL a,LL b,LL &x,LL &y,LL &d)\n{\n\tif(b==0){\n\t\tx = 1; y = 0; d =a;\n\t\treturn;\n\t}\n\texgcd(b,a%b,x,y,d);\n\tLL t=x;\n\tx = y;\n\ty = t - (a/b)*y;\n\treturn;\n}\n\n\nint main()\n{\n\tLL x,y,m,n,l;\n\tcin>>x>>y>>m>>n>>l;\n\tLL v,dis,d,x0,y0;\n\tv  = ABS(m-n);\n\tif(m>n)\n\t\tdis = (y-x+l)%l;\n\telse\n\t\tdis = (x-y+l)%l;\n\t\t\n\texgcd(v,l,x0,y0,d);\n\t\n\tif(d&&dis%d==0){\n\t\tx0 = x0*dis/d;\n\t\tLL t = l/d;\n\t\tx0 = (x0%t+t)%t;\n\t\tcout<<x0<<endl;\n\t}\n\telse{\n\t\tcout<<\"Impossible\"<<endl;\n\t}\n}\n\n```\n","slug":"acm/题解/poj-1061","published":1,"updated":"2017-03-24T17:48:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecf30003uowokqfqsvnv","content":"<h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><p>第一次写扩展欧几里得，感觉最重要的还是最开始就搞懂定理的推导过程，不然会遇到一些坑，在这里简单的mark一下我的理解。 </p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>扩展欧几里得德递归形式和gcd类似，关键在于中途对x,y的处理，重点在理解一下方程的推导：<br><strong>ax1+by1=gcd(a,b)</strong>  ….1<br><strong>bx2+ay2=gcd(b,a%b)</strong>  ….2<br><strong>gcd(a,b)=gcd(b,a%b)</strong>  ….3  </p>\n<p>化简可以得到：x1=y2 y1=x2-a/b*y2  之后便不难理解边界条件设为b=0时，最终可以推出来方程1的一组解x0,y0  </p>\n<h3 id=\"推论\"><a href=\"#推论\" class=\"headerlink\" title=\"推论\"></a>推论</h3><p>重点在于其得到的推论：<strong>ax+by=c 仅当cMODgcd(a,b)=0 时有解</strong><br>设 c = k<em>gcd(a,b)<br>上式可以化简为 a/gcd(a,b)</em>x + b/gcd(a,b)*y = k   =&gt;  Ax+By=k<br>显然AB互质，因而满足方程的解系为(x0-nB,x0+nA) n为任意整数  </p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>就这道题目来说，我觉得对新手来说坑还是有几个：  </p>\n<ol>\n<li>将追逐问题转化为ax+by=c 的不定方程组的解的问题，即确定a和b.</li>\n<li>将exgcd求得的解转化为原方程的解（判断是否有解），并最小化</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ABS(x) (((x)&gt;0)?(x):(-(x)))</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//ax+by = gcd(a,b)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exgcd</span><span class=\"params\">(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\tx = <span class=\"number\">1</span>; y = <span class=\"number\">0</span>; d =a;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\texgcd(b,a%b,x,y,d);</div><div class=\"line\">\tLL t=x;</div><div class=\"line\">\tx = y;</div><div class=\"line\">\ty = t - (a/b)*y;</div><div class=\"line\">\t<span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tLL x,y,m,n,l;</div><div class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l;</div><div class=\"line\">\tLL v,dis,d,x0,y0;</div><div class=\"line\">\tv  = ABS(m-n);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(m&gt;n)</div><div class=\"line\">\t\tdis = (y-x+l)%l;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\tdis = (x-y+l)%l;</div><div class=\"line\">\t\t</div><div class=\"line\">\texgcd(v,l,x0,y0,d);</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">if</span>(d&amp;&amp;dis%d==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\tx0 = x0*dis/d;</div><div class=\"line\">\t\tLL t = l/d;</div><div class=\"line\">\t\tx0 = (x0%t+t)%t;</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;x0&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Impossible\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><p>第一次写扩展欧几里得，感觉最重要的还是最开始就搞懂定理的推导过程，不然会遇到一些坑，在这里简单的mark一下我的理解。 </p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>扩展欧几里得德递归形式和gcd类似，关键在于中途对x,y的处理，重点在理解一下方程的推导：<br><strong>ax1+by1=gcd(a,b)</strong>  ….1<br><strong>bx2+ay2=gcd(b,a%b)</strong>  ….2<br><strong>gcd(a,b)=gcd(b,a%b)</strong>  ….3  </p>\n<p>化简可以得到：x1=y2 y1=x2-a/b*y2  之后便不难理解边界条件设为b=0时，最终可以推出来方程1的一组解x0,y0  </p>\n<h3 id=\"推论\"><a href=\"#推论\" class=\"headerlink\" title=\"推论\"></a>推论</h3><p>重点在于其得到的推论：<strong>ax+by=c 仅当cMODgcd(a,b)=0 时有解</strong><br>设 c = k<em>gcd(a,b)<br>上式可以化简为 a/gcd(a,b)</em>x + b/gcd(a,b)*y = k   =&gt;  Ax+By=k<br>显然AB互质，因而满足方程的解系为(x0-nB,x0+nA) n为任意整数  </p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>就这道题目来说，我觉得对新手来说坑还是有几个：  </p>\n<ol>\n<li>将追逐问题转化为ax+by=c 的不定方程组的解的问题，即确定a和b.</li>\n<li>将exgcd求得的解转化为原方程的解（判断是否有解），并最小化</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ABS(x) (((x)&gt;0)?(x):(-(x)))</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long</span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//ax+by = gcd(a,b)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">exgcd</span><span class=\"params\">(LL a,LL b,LL &amp;x,LL &amp;y,LL &amp;d)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\tx = <span class=\"number\">1</span>; y = <span class=\"number\">0</span>; d =a;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\texgcd(b,a%b,x,y,d);</div><div class=\"line\">\tLL t=x;</div><div class=\"line\">\tx = y;</div><div class=\"line\">\ty = t - (a/b)*y;</div><div class=\"line\">\t<span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tLL x,y,m,n,l;</div><div class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l;</div><div class=\"line\">\tLL v,dis,d,x0,y0;</div><div class=\"line\">\tv  = ABS(m-n);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(m&gt;n)</div><div class=\"line\">\t\tdis = (y-x+l)%l;</div><div class=\"line\">\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\tdis = (x-y+l)%l;</div><div class=\"line\">\t\t</div><div class=\"line\">\texgcd(v,l,x0,y0,d);</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">if</span>(d&amp;&amp;dis%d==<span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\tx0 = x0*dis/d;</div><div class=\"line\">\t\tLL t = l/d;</div><div class=\"line\">\t\tx0 = (x0%t+t)%t;</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;x0&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Impossible\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"poj-2348","date":"2017-04-03T08:37:52.000Z","_content":"\n### 题意分析\n题目给出了两个正数a.b  \n每次操作，大的数减掉小的数的整数倍。一个数变为0 的时候结束。  \n谁先先把其中一个数减为0的获胜。问谁可以赢。Stan是先手。  \n假设两个数为a,b（a>=b)  \n如果a==b.那么肯定是先手获胜。一步就可以减为0,b  \n如果a%b==0.就是a是b的倍数，那么也是先手获胜。  \n如果a>=2*b.  那么   那个人肯定知道a%b,b是必胜态还是必败态。如果是必败态，先手将a,b变成a%b,b,那么先手肯定赢。如果是必胜态，先手将a,b变成a%b+b,b.那么对手只有将这两个数变成a%b,b,先手获胜。  \n如果是b<a<2*b  那么只有一条路：变成a-b,b  (这个时候0<a-b<b).这样一直下去看谁先面对上面的必胜状态。  \n所以假如面对b < a <2*b的状态，就先一步一步走下去。直到面对一个a%b==0 || a >=2*b的状态。  \n\n``` c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define LL long long \n\nusing namespace std;\n\nint main()\n{\n\tint N,M;\n\twhile(~scanf(\"%d%d\",&N,&M))\n\t{\n\t\tif(M==0 && N==0)\tbreak;\n\t\tint a = max(N,M);\n\t\tint b = min(N,M);\n\t\tint nflag = 0;\n\t\tif(a%b==0||a/b>=2)\n\t\t\tnflag = 0;\n\t\telse{\n\t\t\twhile(b){\n\t\t\t\tif(a%b==0||a/b>=2)\tbreak;\n\t\t\t\ta = a-b;\n\t\t\t\tswap(a,b);\n\t\t\t\tnflag ^=1;\n\t\t\t}\n\t\t}\n\t\tif(!nflag)\n\t\t\tputs(\"Stan wins\");\n\t\telse\n\t\t\tputs(\"Ollie wins\");\n\t\t\t\n\t}\n}\n\n```","source":"_posts/acm/题解/poj-2348.md","raw":"---\ntitle: poj-2348\ndate: 2017-04-03 16:37:52\ntags: [博弈论,题解]\ncategories: ACM\n---\n\n### 题意分析\n题目给出了两个正数a.b  \n每次操作，大的数减掉小的数的整数倍。一个数变为0 的时候结束。  \n谁先先把其中一个数减为0的获胜。问谁可以赢。Stan是先手。  \n假设两个数为a,b（a>=b)  \n如果a==b.那么肯定是先手获胜。一步就可以减为0,b  \n如果a%b==0.就是a是b的倍数，那么也是先手获胜。  \n如果a>=2*b.  那么   那个人肯定知道a%b,b是必胜态还是必败态。如果是必败态，先手将a,b变成a%b,b,那么先手肯定赢。如果是必胜态，先手将a,b变成a%b+b,b.那么对手只有将这两个数变成a%b,b,先手获胜。  \n如果是b<a<2*b  那么只有一条路：变成a-b,b  (这个时候0<a-b<b).这样一直下去看谁先面对上面的必胜状态。  \n所以假如面对b < a <2*b的状态，就先一步一步走下去。直到面对一个a%b==0 || a >=2*b的状态。  \n\n``` c++\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define LL long long \n\nusing namespace std;\n\nint main()\n{\n\tint N,M;\n\twhile(~scanf(\"%d%d\",&N,&M))\n\t{\n\t\tif(M==0 && N==0)\tbreak;\n\t\tint a = max(N,M);\n\t\tint b = min(N,M);\n\t\tint nflag = 0;\n\t\tif(a%b==0||a/b>=2)\n\t\t\tnflag = 0;\n\t\telse{\n\t\t\twhile(b){\n\t\t\t\tif(a%b==0||a/b>=2)\tbreak;\n\t\t\t\ta = a-b;\n\t\t\t\tswap(a,b);\n\t\t\t\tnflag ^=1;\n\t\t\t}\n\t\t}\n\t\tif(!nflag)\n\t\t\tputs(\"Stan wins\");\n\t\telse\n\t\t\tputs(\"Ollie wins\");\n\t\t\t\n\t}\n}\n\n```","slug":"acm/题解/poj-2348","published":1,"updated":"2017-04-04T11:42:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecfj0006uowo5jm7f9yt","content":"<h3 id=\"题意分析\"><a href=\"#题意分析\" class=\"headerlink\" title=\"题意分析\"></a>题意分析</h3><p>题目给出了两个正数a.b<br>每次操作，大的数减掉小的数的整数倍。一个数变为0 的时候结束。<br>谁先先把其中一个数减为0的获胜。问谁可以赢。Stan是先手。<br>假设两个数为a,b（a&gt;=b)<br>如果a==b.那么肯定是先手获胜。一步就可以减为0,b<br>如果a%b==0.就是a是b的倍数，那么也是先手获胜。<br>如果a&gt;=2<em>b.  那么   那个人肯定知道a%b,b是必胜态还是必败态。如果是必败态，先手将a,b变成a%b,b,那么先手肯定赢。如果是必胜态，先手将a,b变成a%b+b,b.那么对手只有将这两个数变成a%b,b,先手获胜。<br>如果是b&lt;a&lt;2</em>b  那么只有一条路：变成a-b,b  (这个时候0<a-b<b).这样一直下去看谁先面对上面的必胜状态。 所以假如面对b=\"\" <=\"\" a=\"\" <2*b的状态，就先一步一步走下去。直到面对一个a%b=\"=0\" ||=\"\">=2*b的状态。  </a-b<b).这样一直下去看谁先面对上面的必胜状态。></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> N,M;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;N,&amp;M))</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(M==<span class=\"number\">0</span> &amp;&amp; N==<span class=\"number\">0</span>)\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> a = max(N,M);</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> b = min(N,M);</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> nflag = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(a%b==<span class=\"number\">0</span>||a/b&gt;=<span class=\"number\">2</span>)</div><div class=\"line\">\t\t\tnflag = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span>(b)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a%b==<span class=\"number\">0</span>||a/b&gt;=<span class=\"number\">2</span>)\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t\ta = a-b;</div><div class=\"line\">\t\t\t\tswap(a,b);</div><div class=\"line\">\t\t\t\tnflag ^=<span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!nflag)</div><div class=\"line\">\t\t\t<span class=\"built_in\">puts</span>(<span class=\"string\">\"Stan wins\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">puts</span>(<span class=\"string\">\"Ollie wins\"</span>);</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"题意分析\"><a href=\"#题意分析\" class=\"headerlink\" title=\"题意分析\"></a>题意分析</h3><p>题目给出了两个正数a.b<br>每次操作，大的数减掉小的数的整数倍。一个数变为0 的时候结束。<br>谁先先把其中一个数减为0的获胜。问谁可以赢。Stan是先手。<br>假设两个数为a,b（a&gt;=b)<br>如果a==b.那么肯定是先手获胜。一步就可以减为0,b<br>如果a%b==0.就是a是b的倍数，那么也是先手获胜。<br>如果a&gt;=2<em>b.  那么   那个人肯定知道a%b,b是必胜态还是必败态。如果是必败态，先手将a,b变成a%b,b,那么先手肯定赢。如果是必胜态，先手将a,b变成a%b+b,b.那么对手只有将这两个数变成a%b,b,先手获胜。<br>如果是b&lt;a&lt;2</em>b  那么只有一条路：变成a-b,b  (这个时候0<a-b<b).这样一直下去看谁先面对上面的必胜状态。  \n所以假如面对b < a <2*b的状态，就先一步一步走下去。直到面对一个a%b==0 || a >=2*b的状态。  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LL long long </span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> N,M;</div><div class=\"line\">\t<span class=\"keyword\">while</span>(~<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;N,&amp;M))</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(M==<span class=\"number\">0</span> &amp;&amp; N==<span class=\"number\">0</span>)\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> a = max(N,M);</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> b = min(N,M);</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> nflag = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(a%b==<span class=\"number\">0</span>||a/b&gt;=<span class=\"number\">2</span>)</div><div class=\"line\">\t\t\tnflag = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">while</span>(b)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(a%b==<span class=\"number\">0</span>||a/b&gt;=<span class=\"number\">2</span>)\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t\t\ta = a-b;</div><div class=\"line\">\t\t\t\tswap(a,b);</div><div class=\"line\">\t\t\t\tnflag ^=<span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(!nflag)</div><div class=\"line\">\t\t\t<span class=\"built_in\">puts</span>(<span class=\"string\">\"Stan wins\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">else</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">puts</span>(<span class=\"string\">\"Ollie wins\"</span>);</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"HDU-5667 矩阵快速幂&费马小定理","date":"2017-03-22T04:36:35.000Z","_content":"做题新遇到的知识点，暂时未ac 先markdown\n\n## 快速幂\n\n见算法概论p22  \n### 大致思想\n求 a^b mod N 时，从a mod N 开始不断对结果进行平方后迭代。然后把N对应二进制位为1的地方相乘，实际上是借助了：  \n**a^b = a^(2^k1+2^k2+....)**  \n的思想\n\n\n## 费马小定理\n\n当gcd(a,p)=1 且P为质数的时候有： \n\n**(p-1)mod p=1**\n\n\n\n## HDU-5667\n### 题解\n这一题实际上就是对递推式log然后转化为矩阵快速幂求f(n)时a的幂\n\n### 要点\n1. 从递推式到矩阵要注意，仔细观察递推式，矩阵的维数要恰当\n2. 注意在快速幂的时候模（p-1）\n","source":"_posts/acm/题解/HDU-5667.md","raw":"---\ntitle: HDU-5667 矩阵快速幂&费马小定理 \ndate: 2017-03-22 12:36:35\ntags: [数论,快速幂] \ncategories: ACM\n---\n做题新遇到的知识点，暂时未ac 先markdown\n\n## 快速幂\n\n见算法概论p22  \n### 大致思想\n求 a^b mod N 时，从a mod N 开始不断对结果进行平方后迭代。然后把N对应二进制位为1的地方相乘，实际上是借助了：  \n**a^b = a^(2^k1+2^k2+....)**  \n的思想\n\n\n## 费马小定理\n\n当gcd(a,p)=1 且P为质数的时候有： \n\n**(p-1)mod p=1**\n\n\n\n## HDU-5667\n### 题解\n这一题实际上就是对递推式log然后转化为矩阵快速幂求f(n)时a的幂\n\n### 要点\n1. 从递推式到矩阵要注意，仔细观察递推式，矩阵的维数要恰当\n2. 注意在快速幂的时候模（p-1）\n","slug":"acm/题解/HDU-5667","published":1,"updated":"2017-03-24T11:01:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecfy0009uowoggcwwyjx","content":"<p>做题新遇到的知识点，暂时未ac 先markdown</p>\n<h2 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h2><p>见算法概论p22  </p>\n<h3 id=\"大致思想\"><a href=\"#大致思想\" class=\"headerlink\" title=\"大致思想\"></a>大致思想</h3><p>求 a^b mod N 时，从a mod N 开始不断对结果进行平方后迭代。然后把N对应二进制位为1的地方相乘，实际上是借助了：<br><strong>a^b = a^(2^k1+2^k2+….)</strong><br>的思想</p>\n<h2 id=\"费马小定理\"><a href=\"#费马小定理\" class=\"headerlink\" title=\"费马小定理\"></a>费马小定理</h2><p>当gcd(a,p)=1 且P为质数的时候有： </p>\n<p><strong>(p-1)mod p=1</strong></p>\n<h2 id=\"HDU-5667\"><a href=\"#HDU-5667\" class=\"headerlink\" title=\"HDU-5667\"></a>HDU-5667</h2><h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这一题实际上就是对递推式log然后转化为矩阵快速幂求f(n)时a的幂</p>\n<h3 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h3><ol>\n<li>从递推式到矩阵要注意，仔细观察递推式，矩阵的维数要恰当</li>\n<li>注意在快速幂的时候模（p-1）</li>\n</ol>\n","excerpt":"","more":"<p>做题新遇到的知识点，暂时未ac 先markdown</p>\n<h2 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h2><p>见算法概论p22  </p>\n<h3 id=\"大致思想\"><a href=\"#大致思想\" class=\"headerlink\" title=\"大致思想\"></a>大致思想</h3><p>求 a^b mod N 时，从a mod N 开始不断对结果进行平方后迭代。然后把N对应二进制位为1的地方相乘，实际上是借助了：<br><strong>a^b = a^(2^k1+2^k2+….)</strong><br>的思想</p>\n<h2 id=\"费马小定理\"><a href=\"#费马小定理\" class=\"headerlink\" title=\"费马小定理\"></a>费马小定理</h2><p>当gcd(a,p)=1 且P为质数的时候有： </p>\n<p><strong>(p-1)mod p=1</strong></p>\n<h2 id=\"HDU-5667\"><a href=\"#HDU-5667\" class=\"headerlink\" title=\"HDU-5667\"></a>HDU-5667</h2><h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>这一题实际上就是对递推式log然后转化为矩阵快速幂求f(n)时a的幂</p>\n<h3 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h3><ol>\n<li>从递推式到矩阵要注意，仔细观察递推式，矩阵的维数要恰当</li>\n<li>注意在快速幂的时候模（p-1）</li>\n</ol>\n"},{"title":"组合博弈与SG函数","date":"2017-04-03T06:04:03.000Z","_content":"\n## 组合博弈\n\n### 组合博弈的规则（Imaprtial Combinatorial Games）\n 1. 有两名选手  \n 2. 两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动\n 3. 对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； \n 4. 如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。\n\n### 对NP状态的定义\n1. 无法进行任何移动的局面（也就是terminal position）是P-position；\n2. 可以移动到P-position的局面是N-position；\n3. 所有移动都导致N-position的局面是P-position。\n\n## SG函数\n\n### mex运算\n首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。\n\n### SG 函数的定义\n对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。\n\n\n### 分析\n来看一下SG函数的性质。首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。然后对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。  \n\n以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了\n\n我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。\n\n### 证明\n\n根据上述定义只需要证明SG值为0和不为0时满足P态和N态的性质即可  \n1. 集合为空的时候不存在后继集合，SG值为0\n2. 当g(G)=g(G1)^g(G2)^...^g(Gn)=k 时，必存在g(Gk)，有g(Gk)^k < g(Gk)从而存在对第k个子游戏的一种操作，使g(Gk)'=g(Gk)^k 从而g(G)' = 0\n3. 当g(G)=g(G1)^g(G2)^...^g(Gn)=0时对任意一个子游戏进行操作必得到g(Gk)'<g(Gk)，从而g(G)'!=0 为N态，故g(G)=0时为P态\n\n![](/images/还有这种操作.jpg)\n\n### SG函数的应用\n一个组合博弈分为N个子博弈，组合博弈的SG函数值就是子博弈SG函数值的异或。\n在前面的Nim游戏当中，N个堆的分别的SG值就是当前堆的石子数（可以一次性全部取完）\n\n#### 关于怎么去求SG函数的值   \n根据定义我们知道求SG函数的值有几个关键的点：\n1. 求当前状态的所有后缀状态的SG值\n2. 对所有后缀的SG值进行Mes操作\n\n因此，我们需要从终态状态开始，逐个求SG值，这就要求把局面转化为一个现态到终态递减的值或者在求SG值的时候注意安排现态在所有次态求出后  \n对于Mes操作，先记录每一个后缀状态SG值的出现状况，然后找出第一个未出现的值即可  \n可以用以下代码表示\n```c++\n//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理  \n//SG[]:0~n的SG函数值  \n//S[]:为x后继状态的集合  \nint f[N],SG[MAXN],S[MAXN];  \nvoid  getSG(int n){  \n    int i,j;  \n    memset(SG,0,sizeof(SG));  \n    //因为SG[0]始终等于0，所以i从1开始  \n    for(i = 1; i <= n; i++){  \n        //每一次都要将上一状态 的 后继集合 重置  \n        memset(S,0,sizeof(S));  \n        for(j = 0; f[j] <= i && j <= N; j++)  \n            S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记  \n        for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值  \n            SG[i] = j;  \n            break;  \n        }  \n    }  \n}  \n```\n\n对于有一类题SG函数值是存在规律的，对于输入量明显较大的题，可以先打个表找出SG函数的规律，对于另外一种\n就需要把整个SG函数表保存起来\n\n参考资料：\nhttp://www.wutianqi.com/?p=1081","source":"_posts/acm/题解/组合博弈与SG函数.md","raw":"---\ntitle: 组合博弈与SG函数\ndate: 2017-04-03 14:04:03\ntags: [博弈论]\ncategories: ACM\n---\n\n## 组合博弈\n\n### 组合博弈的规则（Imaprtial Combinatorial Games）\n 1. 有两名选手  \n 2. 两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动\n 3. 对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； \n 4. 如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。\n\n### 对NP状态的定义\n1. 无法进行任何移动的局面（也就是terminal position）是P-position；\n2. 可以移动到P-position的局面是N-position；\n3. 所有移动都导致N-position的局面是P-position。\n\n## SG函数\n\n### mex运算\n首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。\n\n### SG 函数的定义\n对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。\n\n\n### 分析\n来看一下SG函数的性质。首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。然后对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。  \n\n以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了\n\n我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^...^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。\n\n### 证明\n\n根据上述定义只需要证明SG值为0和不为0时满足P态和N态的性质即可  \n1. 集合为空的时候不存在后继集合，SG值为0\n2. 当g(G)=g(G1)^g(G2)^...^g(Gn)=k 时，必存在g(Gk)，有g(Gk)^k < g(Gk)从而存在对第k个子游戏的一种操作，使g(Gk)'=g(Gk)^k 从而g(G)' = 0\n3. 当g(G)=g(G1)^g(G2)^...^g(Gn)=0时对任意一个子游戏进行操作必得到g(Gk)'<g(Gk)，从而g(G)'!=0 为N态，故g(G)=0时为P态\n\n![](/images/还有这种操作.jpg)\n\n### SG函数的应用\n一个组合博弈分为N个子博弈，组合博弈的SG函数值就是子博弈SG函数值的异或。\n在前面的Nim游戏当中，N个堆的分别的SG值就是当前堆的石子数（可以一次性全部取完）\n\n#### 关于怎么去求SG函数的值   \n根据定义我们知道求SG函数的值有几个关键的点：\n1. 求当前状态的所有后缀状态的SG值\n2. 对所有后缀的SG值进行Mes操作\n\n因此，我们需要从终态状态开始，逐个求SG值，这就要求把局面转化为一个现态到终态递减的值或者在求SG值的时候注意安排现态在所有次态求出后  \n对于Mes操作，先记录每一个后缀状态SG值的出现状况，然后找出第一个未出现的值即可  \n可以用以下代码表示\n```c++\n//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理  \n//SG[]:0~n的SG函数值  \n//S[]:为x后继状态的集合  \nint f[N],SG[MAXN],S[MAXN];  \nvoid  getSG(int n){  \n    int i,j;  \n    memset(SG,0,sizeof(SG));  \n    //因为SG[0]始终等于0，所以i从1开始  \n    for(i = 1; i <= n; i++){  \n        //每一次都要将上一状态 的 后继集合 重置  \n        memset(S,0,sizeof(S));  \n        for(j = 0; f[j] <= i && j <= N; j++)  \n            S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记  \n        for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值  \n            SG[i] = j;  \n            break;  \n        }  \n    }  \n}  \n```\n\n对于有一类题SG函数值是存在规律的，对于输入量明显较大的题，可以先打个表找出SG函数的规律，对于另外一种\n就需要把整个SG函数表保存起来\n\n参考资料：\nhttp://www.wutianqi.com/?p=1081","slug":"acm/题解/组合博弈与SG函数","published":1,"updated":"2017-04-03T07:30:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecge000cuowo5m5deeyz","content":"<h2 id=\"组合博弈\"><a href=\"#组合博弈\" class=\"headerlink\" title=\"组合博弈\"></a>组合博弈</h2><h3 id=\"组合博弈的规则（Imaprtial-Combinatorial-Games）\"><a href=\"#组合博弈的规则（Imaprtial-Combinatorial-Games）\" class=\"headerlink\" title=\"组合博弈的规则（Imaprtial Combinatorial Games）\"></a>组合博弈的规则（Imaprtial Combinatorial Games）</h3><ol>\n<li>有两名选手  </li>\n<li>两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动</li>\n<li>对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； </li>\n<li>如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。</li>\n</ol>\n<h3 id=\"对NP状态的定义\"><a href=\"#对NP状态的定义\" class=\"headerlink\" title=\"对NP状态的定义\"></a>对NP状态的定义</h3><ol>\n<li>无法进行任何移动的局面（也就是terminal position）是P-position；</li>\n<li>可以移动到P-position的局面是N-position；</li>\n<li>所有移动都导致N-position的局面是P-position。</li>\n</ol>\n<h2 id=\"SG函数\"><a href=\"#SG函数\" class=\"headerlink\" title=\"SG函数\"></a>SG函数</h2><h3 id=\"mex运算\"><a href=\"#mex运算\" class=\"headerlink\" title=\"mex运算\"></a>mex运算</h3><p>首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p>\n<h3 id=\"SG-函数的定义\"><a href=\"#SG-函数的定义\" class=\"headerlink\" title=\"SG 函数的定义\"></a>SG 函数的定义</h3><p>对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>来看一下SG函数的性质。首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。然后对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。  </p>\n<p>以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了</p>\n<p>我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^…^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>根据上述定义只需要证明SG值为0和不为0时满足P态和N态的性质即可  </p>\n<ol>\n<li>集合为空的时候不存在后继集合，SG值为0</li>\n<li>当g(G)=g(G1)^g(G2)^…^g(Gn)=k 时，必存在g(Gk)，有g(Gk)^k &lt; g(Gk)从而存在对第k个子游戏的一种操作，使g(Gk)’=g(Gk)^k 从而g(G)’ = 0</li>\n<li>当g(G)=g(G1)^g(G2)^…^g(Gn)=0时对任意一个子游戏进行操作必得到g(Gk)’&lt;g(Gk)，从而g(G)’!=0 为N态，故g(G)=0时为P态</li>\n</ol>\n<p><img src=\"/images/还有这种操作.jpg\" alt=\"\"></p>\n<h3 id=\"SG函数的应用\"><a href=\"#SG函数的应用\" class=\"headerlink\" title=\"SG函数的应用\"></a>SG函数的应用</h3><p>一个组合博弈分为N个子博弈，组合博弈的SG函数值就是子博弈SG函数值的异或。<br>在前面的Nim游戏当中，N个堆的分别的SG值就是当前堆的石子数（可以一次性全部取完）</p>\n<h4 id=\"关于怎么去求SG函数的值\"><a href=\"#关于怎么去求SG函数的值\" class=\"headerlink\" title=\"关于怎么去求SG函数的值\"></a>关于怎么去求SG函数的值</h4><p>根据定义我们知道求SG函数的值有几个关键的点：</p>\n<ol>\n<li>求当前状态的所有后缀状态的SG值</li>\n<li>对所有后缀的SG值进行Mes操作</li>\n</ol>\n<p>因此，我们需要从终态状态开始，逐个求SG值，这就要求把局面转化为一个现态到终态递减的值或者在求SG值的时候注意安排现态在所有次态求出后<br>对于Mes操作，先记录每一个后缀状态SG值的出现状况，然后找出第一个未出现的值即可<br>可以用以下代码表示<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理  </span></div><div class=\"line\"><span class=\"comment\">//SG[]:0~n的SG函数值  </span></div><div class=\"line\"><span class=\"comment\">//S[]:为x后继状态的集合  </span></div><div class=\"line\"><span class=\"keyword\">int</span> f[N],SG[MAXN],S[MAXN];  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">getSG</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">int</span> i,j;  </div><div class=\"line\">    <span class=\"built_in\">memset</span>(SG,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(SG));  </div><div class=\"line\">    <span class=\"comment\">//因为SG[0]始终等于0，所以i从1开始  </span></div><div class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;  </div><div class=\"line\">        <span class=\"comment\">//每一次都要将上一状态 的 后继集合 重置  </span></div><div class=\"line\">        <span class=\"built_in\">memset</span>(S,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(S));  </div><div class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; f[j] &lt;= i &amp;&amp; j &lt;= N; j++)  </div><div class=\"line\">            S[SG[i-f[j]]] = <span class=\"number\">1</span>;  <span class=\"comment\">//将后继状态的SG函数值进行标记  </span></div><div class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;; j++) <span class=\"keyword\">if</span>(!S[j])&#123;   <span class=\"comment\">//查询当前后继状态SG值中最小的非零值  </span></div><div class=\"line\">            SG[i] = j;  </div><div class=\"line\">            <span class=\"keyword\">break</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>对于有一类题SG函数值是存在规律的，对于输入量明显较大的题，可以先打个表找出SG函数的规律，对于另外一种<br>就需要把整个SG函数表保存起来</p>\n<p>参考资料：<br><a href=\"http://www.wutianqi.com/?p=1081\" target=\"_blank\" rel=\"external\">http://www.wutianqi.com/?p=1081</a></p>\n","excerpt":"","more":"<h2 id=\"组合博弈\"><a href=\"#组合博弈\" class=\"headerlink\" title=\"组合博弈\"></a>组合博弈</h2><h3 id=\"组合博弈的规则（Imaprtial-Combinatorial-Games）\"><a href=\"#组合博弈的规则（Imaprtial-Combinatorial-Games）\" class=\"headerlink\" title=\"组合博弈的规则（Imaprtial Combinatorial Games）\"></a>组合博弈的规则（Imaprtial Combinatorial Games）</h3><ol>\n<li>有两名选手  </li>\n<li>两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动</li>\n<li>对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素； </li>\n<li>如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。</li>\n</ol>\n<h3 id=\"对NP状态的定义\"><a href=\"#对NP状态的定义\" class=\"headerlink\" title=\"对NP状态的定义\"></a>对NP状态的定义</h3><ol>\n<li>无法进行任何移动的局面（也就是terminal position）是P-position；</li>\n<li>可以移动到P-position的局面是N-position；</li>\n<li>所有移动都导致N-position的局面是P-position。</li>\n</ol>\n<h2 id=\"SG函数\"><a href=\"#SG函数\" class=\"headerlink\" title=\"SG函数\"></a>SG函数</h2><h3 id=\"mex运算\"><a href=\"#mex运算\" class=\"headerlink\" title=\"mex运算\"></a>mex运算</h3><p>首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p>\n<h3 id=\"SG-函数的定义\"><a href=\"#SG-函数的定义\" class=\"headerlink\" title=\"SG 函数的定义\"></a>SG 函数的定义</h3><p>对于一个给定的有向无环图，定义关于图的每个顶点的Sprague-Garundy函数g如下：g(x)=mex{ g(y) | y是x的后继 }。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>来看一下SG函数的性质。首先，所有的terminal position所对应的顶点，也就是没有出边的顶点，其SG值为0，因为它的后继集合是空集。然后对于一个g(x)=0的顶点x，它的所有后继y都满足g(y)!=0。对于一个g(x)!=0的顶点，必定存在一个后继y满足g(y)=0。  </p>\n<p>以上这三句话表明，顶点x所代表的postion是P-position当且仅当g(x)=0（跟P-positioin/N-position的定义的那三句话是完全对应的）。我们通过计算有向无环图的每个顶点的SG值，就可以对每种局面找到必胜策略了</p>\n<p>我们可以定义有向图游戏的和(Sum of Graph Games)：设G1、G2、……、Gn是n个有向图游戏，定义游戏G是G1、G2、……、Gn的和(Sum)，游戏G的移动规则是：任选一个子游戏Gi并移动上面的棋子。Sprague-Grundy Theorem就是：g(G)=g(G1)^g(G2)^…^g(Gn)。也就是说，游戏的和的SG函数值是它的所有子游戏的SG函数值的异或。</p>\n<h3 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h3><p>根据上述定义只需要证明SG值为0和不为0时满足P态和N态的性质即可  </p>\n<ol>\n<li>集合为空的时候不存在后继集合，SG值为0</li>\n<li>当g(G)=g(G1)^g(G2)^…^g(Gn)=k 时，必存在g(Gk)，有g(Gk)^k &lt; g(Gk)从而存在对第k个子游戏的一种操作，使g(Gk)’=g(Gk)^k 从而g(G)’ = 0</li>\n<li>当g(G)=g(G1)^g(G2)^…^g(Gn)=0时对任意一个子游戏进行操作必得到g(Gk)’&lt;g(Gk)，从而g(G)’!=0 为N态，故g(G)=0时为P态</li>\n</ol>\n<p><img src=\"/images/还有这种操作.jpg\" alt=\"\"></p>\n<h3 id=\"SG函数的应用\"><a href=\"#SG函数的应用\" class=\"headerlink\" title=\"SG函数的应用\"></a>SG函数的应用</h3><p>一个组合博弈分为N个子博弈，组合博弈的SG函数值就是子博弈SG函数值的异或。<br>在前面的Nim游戏当中，N个堆的分别的SG值就是当前堆的石子数（可以一次性全部取完）</p>\n<h4 id=\"关于怎么去求SG函数的值\"><a href=\"#关于怎么去求SG函数的值\" class=\"headerlink\" title=\"关于怎么去求SG函数的值\"></a>关于怎么去求SG函数的值</h4><p>根据定义我们知道求SG函数的值有几个关键的点：</p>\n<ol>\n<li>求当前状态的所有后缀状态的SG值</li>\n<li>对所有后缀的SG值进行Mes操作</li>\n</ol>\n<p>因此，我们需要从终态状态开始，逐个求SG值，这就要求把局面转化为一个现态到终态递减的值或者在求SG值的时候注意安排现态在所有次态求出后<br>对于Mes操作，先记录每一个后缀状态SG值的出现状况，然后找出第一个未出现的值即可<br>可以用以下代码表示<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理  </span></div><div class=\"line\"><span class=\"comment\">//SG[]:0~n的SG函数值  </span></div><div class=\"line\"><span class=\"comment\">//S[]:为x后继状态的集合  </span></div><div class=\"line\"><span class=\"keyword\">int</span> f[N],SG[MAXN],S[MAXN];  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">getSG</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">int</span> i,j;  </div><div class=\"line\">    <span class=\"built_in\">memset</span>(SG,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(SG));  </div><div class=\"line\">    <span class=\"comment\">//因为SG[0]始终等于0，所以i从1开始  </span></div><div class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;  </div><div class=\"line\">        <span class=\"comment\">//每一次都要将上一状态 的 后继集合 重置  </span></div><div class=\"line\">        <span class=\"built_in\">memset</span>(S,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(S));  </div><div class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; f[j] &lt;= i &amp;&amp; j &lt;= N; j++)  </div><div class=\"line\">            S[SG[i-f[j]]] = <span class=\"number\">1</span>;  <span class=\"comment\">//将后继状态的SG函数值进行标记  </span></div><div class=\"line\">        <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>;; j++) <span class=\"keyword\">if</span>(!S[j])&#123;   <span class=\"comment\">//查询当前后继状态SG值中最小的非零值  </span></div><div class=\"line\">            SG[i] = j;  </div><div class=\"line\">            <span class=\"keyword\">break</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>对于有一类题SG函数值是存在规律的，对于输入量明显较大的题，可以先打个表找出SG函数的规律，对于另外一种<br>就需要把整个SG函数表保存起来</p>\n<p>参考资料：<br><a href=\"http://www.wutianqi.com/?p=1081\">http://www.wutianqi.com/?p=1081</a></p>\n"},{"title":"异或运算的一个性质","date":"2017-08-12T16:03:34.000Z","_content":"\n## 一个结论\n1 ^ 2 ^ 3 ^ 4.....^ n是可以在O（1）时间内计算出来的\n参考如下代码\n```c++\nll xor_n(ll n)\n{\n ll t = n & 3;\n if (t & 1) return t / 2LL ^ 1;\n return t / 2LL ^ n;\n}\n```","source":"_posts/acm/markdown/math/有关异或运算.md","raw":"---\ntitle: 异或运算的一个性质\ndate: 2017-08-13 00:03:34\ncategories: ACM\ntags:  [数论,异或]\n---\n\n## 一个结论\n1 ^ 2 ^ 3 ^ 4.....^ n是可以在O（1）时间内计算出来的\n参考如下代码\n```c++\nll xor_n(ll n)\n{\n ll t = n & 3;\n if (t & 1) return t / 2LL ^ 1;\n return t / 2LL ^ n;\n}\n```","slug":"acm/markdown/math/有关异或运算","published":1,"updated":"2017-08-27T11:43:53.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecj6000luowohh86jpo0","content":"<h2 id=\"一个结论\"><a href=\"#一个结论\" class=\"headerlink\" title=\"一个结论\"></a>一个结论</h2><p>1 ^ 2 ^ 3 ^ 4…..^ n是可以在O（1）时间内计算出来的<br>参考如下代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">ll <span class=\"title\">xor_n</span><span class=\"params\">(ll n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"> ll t = n &amp; <span class=\"number\">3</span>;</div><div class=\"line\"> <span class=\"keyword\">if</span> (t &amp; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> t / <span class=\"number\">2L</span>L ^ <span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"keyword\">return</span> t / <span class=\"number\">2L</span>L ^ n;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h2 id=\"一个结论\"><a href=\"#一个结论\" class=\"headerlink\" title=\"一个结论\"></a>一个结论</h2><p>1 ^ 2 ^ 3 ^ 4…..^ n是可以在O（1）时间内计算出来的<br>参考如下代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">ll <span class=\"title\">xor_n</span><span class=\"params\">(ll n)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\"> ll t = n &amp; <span class=\"number\">3</span>;</div><div class=\"line\"> <span class=\"keyword\">if</span> (t &amp; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> t / <span class=\"number\">2L</span>L ^ <span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"keyword\">return</span> t / <span class=\"number\">2L</span>L ^ n;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"素数线性筛法","date":"2017-08-20T04:03:34.000Z","_content":"\n时间复杂度O（N）\n```c++\nbool isprime[10000005];\nint prime[1000004];\nint cnt = 0;\n\nvoid sift(int n)\n{\n    memset(isprime,true,sizeof(isprime));\n    for(int i=2; i<=n; i++){\n\n        if(isprime[i])\n            prime[cnt++] = i;\n        for(int j=0; j<cnt&&prime[j]*i<=n; j++){\n            isprime[prime[j]*i] = false;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n```","source":"_posts/acm/markdown/math/素数线性筛法.md","raw":"---\ntitle: 素数线性筛法\ndate: 2017-8-20 12:03:34\ncategories: ACM\ntags:  [数论,线性筛法]\n---\n\n时间复杂度O（N）\n```c++\nbool isprime[10000005];\nint prime[1000004];\nint cnt = 0;\n\nvoid sift(int n)\n{\n    memset(isprime,true,sizeof(isprime));\n    for(int i=2; i<=n; i++){\n\n        if(isprime[i])\n            prime[cnt++] = i;\n        for(int j=0; j<cnt&&prime[j]*i<=n; j++){\n            isprime[prime[j]*i] = false;\n            if(i%prime[j]==0) break;\n        }\n    }\n}\n```","slug":"acm/markdown/math/素数线性筛法","published":1,"updated":"2017-08-27T11:43:11.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecj6000muowo8alirldh","content":"<p>时间复杂度O（N）<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">bool</span> isprime[<span class=\"number\">10000005</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> prime[<span class=\"number\">1000004</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sift</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(isprime,<span class=\"literal\">true</span>,<span class=\"keyword\">sizeof</span>(isprime));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>; i&lt;=n; i++)&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(isprime[i])</div><div class=\"line\">            prime[cnt++] = i;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;cnt&amp;&amp;prime[j]*i&lt;=n; j++)&#123;</div><div class=\"line\">            isprime[prime[j]*i] = <span class=\"literal\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>(i%prime[j]==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>时间复杂度O（N）<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">bool</span> isprime[<span class=\"number\">10000005</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> prime[<span class=\"number\">1000004</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sift</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(isprime,<span class=\"literal\">true</span>,<span class=\"keyword\">sizeof</span>(isprime));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>; i&lt;=n; i++)&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(isprime[i])</div><div class=\"line\">            prime[cnt++] = i;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;cnt&amp;&amp;prime[j]*i&lt;=n; j++)&#123;</div><div class=\"line\">            isprime[prime[j]*i] = <span class=\"literal\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>(i%prime[j]==<span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"欧拉函数及一些性质","date":"2017-08-20T04:03:34.000Z","_content":"\n\n## 唯一分解定理\n\n## 欧拉函数的一些性质\n\n\n**一些公式**  \n1. 若p q互质则有  \n```math\n    phi(N)=phi(p)*phi(q)  \n    \n    (N=p*q)\n```\n2. 当b是质数，a%b=0 则\n```math\n    phi(ab) = phi(a)*b\n```\n\n\n**递推式**   \n对于质数p满足p|x\n1. 若p^2|x不成立,因x/p互质故有：\n```math\n    phi(x)=phi(x/p)*(p-1)\n```\n2. 若p^2|x成立,p|(x/p)且p为质数\n```math\n    phi(x)=phi(x/p)*p\n```\n\n**公式求欧拉函数：**\n    \n```math\nphi(N) = n*(1+1/p1)(1+1/p2)...(1+1/pk)\n```\n其中\n\n```math\nN = p1^a*p2^b*...pk^x\n```\n\n因而可以写出如下的代码用公式求欧拉函数值\n```c++\n    for(int i=1; i<=MAXN; i++)\n        phi[i] = i;\n    for(int i=2; i<=MAXN; i++)\n        if(phi[i]==i){\n            for(int j=i; j<=MAXN; j+=i)\n                phi[j] = phi[j]/i*(i-1);\n        }\n```\n\n\n**lightoj-1370:** \n \n    结论： phi(x)~x之间一定存在一个质数\n    \n\n","source":"_posts/acm/markdown/math/欧拉函数.md","raw":"---\ntitle: 欧拉函数及一些性质\ndate: 2017-8-20 12:03:34\ncategories: ACM\ntags:  [数论,欧拉函数]\n---\n\n\n## 唯一分解定理\n\n## 欧拉函数的一些性质\n\n\n**一些公式**  \n1. 若p q互质则有  \n```math\n    phi(N)=phi(p)*phi(q)  \n    \n    (N=p*q)\n```\n2. 当b是质数，a%b=0 则\n```math\n    phi(ab) = phi(a)*b\n```\n\n\n**递推式**   \n对于质数p满足p|x\n1. 若p^2|x不成立,因x/p互质故有：\n```math\n    phi(x)=phi(x/p)*(p-1)\n```\n2. 若p^2|x成立,p|(x/p)且p为质数\n```math\n    phi(x)=phi(x/p)*p\n```\n\n**公式求欧拉函数：**\n    \n```math\nphi(N) = n*(1+1/p1)(1+1/p2)...(1+1/pk)\n```\n其中\n\n```math\nN = p1^a*p2^b*...pk^x\n```\n\n因而可以写出如下的代码用公式求欧拉函数值\n```c++\n    for(int i=1; i<=MAXN; i++)\n        phi[i] = i;\n    for(int i=2; i<=MAXN; i++)\n        if(phi[i]==i){\n            for(int j=i; j<=MAXN; j+=i)\n                phi[j] = phi[j]/i*(i-1);\n        }\n```\n\n\n**lightoj-1370:** \n \n    结论： phi(x)~x之间一定存在一个质数\n    \n\n","slug":"acm/markdown/math/欧拉函数","published":1,"updated":"2017-08-27T11:42:27.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoeck1000ouowoszso4zyo","content":"<h2 id=\"唯一分解定理\"><a href=\"#唯一分解定理\" class=\"headerlink\" title=\"唯一分解定理\"></a>唯一分解定理</h2><h2 id=\"欧拉函数的一些性质\"><a href=\"#欧拉函数的一些性质\" class=\"headerlink\" title=\"欧拉函数的一些性质\"></a>欧拉函数的一些性质</h2><p><strong>一些公式</strong>  </p>\n<ol>\n<li><p>若p q互质则有  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(N)=phi(p)*phi(q)  </div><div class=\"line\"></div><div class=\"line\">(N=p*q)</div></pre></td></tr></table></figure>\n</li>\n<li><p>当b是质数，a%b=0 则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(ab) = phi(a)*b</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>递推式</strong><br>对于质数p满足p|x</p>\n<ol>\n<li><p>若p^2|x不成立,因x/p互质故有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(x)=phi(x/p)*(p-1)</div></pre></td></tr></table></figure>\n</li>\n<li><p>若p^2|x成立,p|(x/p)且p为质数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(x)=phi(x/p)*p</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>公式求欧拉函数：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(N) = n*(1+1/p1)(1+1/p2)...(1+1/pk)</div></pre></td></tr></table></figure>\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">N = p1^a*p2^b*...pk^x</div></pre></td></tr></table></figure>\n<p>因而可以写出如下的代码用公式求欧拉函数值<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=MAXN; i++)</div><div class=\"line\">    phi[i] = i;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>; i&lt;=MAXN; i++)</div><div class=\"line\">    <span class=\"keyword\">if</span>(phi[i]==i)&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i; j&lt;=MAXN; j+=i)</div><div class=\"line\">            phi[j] = phi[j]/i*(i<span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><strong>lightoj-1370:</strong> </p>\n<pre><code>结论： phi(x)~x之间一定存在一个质数\n</code></pre>","excerpt":"","more":"<h2 id=\"唯一分解定理\"><a href=\"#唯一分解定理\" class=\"headerlink\" title=\"唯一分解定理\"></a>唯一分解定理</h2><h2 id=\"欧拉函数的一些性质\"><a href=\"#欧拉函数的一些性质\" class=\"headerlink\" title=\"欧拉函数的一些性质\"></a>欧拉函数的一些性质</h2><p><strong>一些公式</strong>  </p>\n<ol>\n<li><p>若p q互质则有  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(N)=phi(p)*phi(q)  </div><div class=\"line\"></div><div class=\"line\">(N=p*q)</div></pre></td></tr></table></figure>\n</li>\n<li><p>当b是质数，a%b=0 则</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(ab) = phi(a)*b</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>递推式</strong><br>对于质数p满足p|x</p>\n<ol>\n<li><p>若p^2|x不成立,因x/p互质故有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(x)=phi(x/p)*(p-1)</div></pre></td></tr></table></figure>\n</li>\n<li><p>若p^2|x成立,p|(x/p)且p为质数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(x)=phi(x/p)*p</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>公式求欧拉函数：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">phi(N) = n*(1+1/p1)(1+1/p2)...(1+1/pk)</div></pre></td></tr></table></figure>\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">N = p1^a*p2^b*...pk^x</div></pre></td></tr></table></figure>\n<p>因而可以写出如下的代码用公式求欧拉函数值<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=MAXN; i++)</div><div class=\"line\">    phi[i] = i;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>; i&lt;=MAXN; i++)</div><div class=\"line\">    <span class=\"keyword\">if</span>(phi[i]==i)&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i; j&lt;=MAXN; j+=i)</div><div class=\"line\">            phi[j] = phi[j]/i*(i<span class=\"number\">-1</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p><strong>lightoj-1370:</strong> </p>\n<pre><code>结论： phi(x)~x之间一定存在一个质数\n</code></pre>"},{"title":"二分图最大匹配的匈牙利算法和性质","date":"2017-08-20T04:03:34.000Z","_content":"\n# 二分图最大匹配\n\n## 最大匹配的匈牙利算法\n### 最大匹配：\n在G的一个子图M中，M的边集中的任意两条边都不依附于 同一个顶点，则称M是一个匹配。选择这样的边数最大的子集称为图的最大匹配问题,最大匹配的边数称为最大匹配数.如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。如果在左右两边加上源汇点后，图G等价于一个网络流，最大匹配问题可以转为最大流的问题。解决此问的匈牙利算法的本质就是寻找最大流的增广路径。  \n\n模板如下\n```c++\n/*\n    匈牙利算法\n    解决最大匹配问题\n    临接表版本\n*/\nstruct edge{\n    int to,next;\n}edge[MAXN];\nint head[MAXN],tot;\nvoid init()\n{\n    tot = 0;\n    memset(head,-1,sizeof(head));\n}\n\nvoid addedge(int u,int v)\n{\n    edge[tot].to = v;   edge[tot].next = head[u];\n    head[u] = tot++;\n}\nint linker[MAXN];\nint used[MAXN];\nint uN;         //点的编号0~uN-1\n\nbool dfs(int u)\n{\n    for(int i=head[u]; i!=-1; i=edge[i].next)\n    {\n        int v = edge[i].to;\n        if(!used[v])\n        {\n            used[v] = true;\n            if(linker[v]==-1 || dfs(linker[v])){\n                linker[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(linker,-1,sizeof(linker));\n    for(itn u=0; u<uN; u++){\n        memset(used,false,sizeof(used));\n        if(dfs(u))  res++;\n    }\n    return res;\n}\n\n/*\n邻接矩阵的匈牙利算法\n最小点覆盖等价于最大匹配，对每一个X集合未覆盖点出发进行一次匈牙利树扩展（dfs（））最后X内未标记和Y内已标记的集合组成最小覆盖\nmin_cover用来通过扩展匈牙利树寻找最小点覆盖\n*/\nint R,C,N;\nint uN,vN;\nint G[MAXN][MAXN];\nint Left[MAXN];\nint Right[MAXN];\nbool S[MAXN],T[MAXN];\n\nbool dfs(int u)\n{\n    S[u] = true;\n    for(int v=1; v<=vN;v++)\n    if(G[u][v] && !T[v]){\n        T[v] = true;\n        if(Left[v] == -1 || dfs(Left[v])){\n            Right[u] = v;\n            Left[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(Left,-1,sizeof(Left));\n    memset(Right,-1,sizeof(Right));\n    for(int u=1; u<=uN; u++){\n        memset(T,0,sizeof(T));\n        if(dfs(u)) res++;\n    }\n    return res;\n}\n\nint min_cover(vector<int> &X,vector<int> &Y)\n{\n    int ans = hungary();\n    X.clear();  Y.clear();\n    memset(S,0,sizeof(S));\n    memset(T,0,sizeof(T));\n    for(int i=1;i<=uN;i++)\n        if(Right[i]==-1) dfs(i);\n    for(int i=1;i<=uN;i++)\n        if(!S[i]) X.pb(i);\n    for(int j=1;j<=vN;j++)\n        if(T[j]) Y.pb(j);\n    return ans;\n}\n```\n\n\n## 二分图的一些特有性质\n### 最小覆盖\n1. **最小定点覆盖**:  \n    最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联，二分图的最小顶点覆盖数=二分图的最大匹配数。  \n**最小定点覆盖的证明**：  \n首先，最小点集覆盖一定>=最大匹配，因为假设最大匹配为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就要用到n个点。现在我们来思考为什么最小点击覆盖一定<=最大匹配。任何一种n个点的最小点击覆盖，一定可以转化成一个n的最大匹配。因为最小点集覆盖中的每个点都能找到至少一条只有一个端点在点集中的边（如果找不到则说明该点所有的边的另外一个端点都被覆盖，所以该点则没必要被覆盖，和它在最小点集覆盖中相矛盾），只要每个端点都选择一个这样的边，就必然能转化为一个匹配数与点集覆盖的点数相等的匹配方案。所以最大匹配至少为最小点集覆盖数，即最小点击覆盖一定<=最大匹配。综上，二者相等。\n\n2. **最小边覆盖**：  \n    最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图的最小路径覆盖数=|V|-二分图的最大匹配数。  \n    **最小边覆盖的证明**：  \n不妨设最小定点覆盖为X一共V个点，那么，最小边覆盖一定》=V-X。原因在于，首先根据最小点覆盖覆盖所有边的性质，最小点覆盖没取到的V-X条边两两无边相连，**也就是说他们是一个独立子集**，那么最小边覆盖要取到所有点的话就需要这V-X个点每个点取一条边。同时V-X又是取得到的，由于原图最小顶点覆盖就是最大二分匹配，每次取边的是后总是遵循是匹配边的话取匹配边，否则任取。那么结果一定取到了所有定点 \n\n\n\n**从二分最大匹配找到最小点覆盖**    \n需要借助匈牙利树： 设二分图两个集合为X Y  \n从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖\n\n### 最大独立集\n**最大独立集=V-最小覆盖集=V-最大匹配**  \n    \n    ![image](./二分图.png)\n    \n上图，我们用两个红色的点覆盖了所有边。我们证明的前提条件是已经达到最小覆盖。\n即条件1.已经覆盖所有边，条件2.所用的点数最小  \n**首先我们来证明蓝色点组成的是一个独立集：**   \n如果有两个蓝色点间有边相连，那么这条边则没有被覆盖，则与条件1矛盾。因此是独立集。  \n**再来证明这个独立集最大：**  \n如果我们要再增加这个独立集中的点，则需要把某个红点变成蓝点。而由最小覆盖数=最大匹配数的证明我们知道，每一个红点是最大匹配中的一个匹配点，也就是说每个红点至少连接了一条边。因此当我们将某个红点变成蓝点时，我们需要牺牲的蓝点的个数是大于等于1的。也就是说，我们最多只能找到数量相等的其他独立集，而无法找到数量更大的。因此蓝色点集必定为最大独立集。 蓝色点数 =总点数 - 红色点数，即最大独立集=总数-最小覆盖集。\n\n    ","source":"_posts/acm/markdown/图论/二分图.md","raw":"---\ntitle: 二分图最大匹配的匈牙利算法和性质\ndate: 2017-8-20 12:03:34\ncategories: ACM\ntags:  [二分图]\n---\n\n# 二分图最大匹配\n\n## 最大匹配的匈牙利算法\n### 最大匹配：\n在G的一个子图M中，M的边集中的任意两条边都不依附于 同一个顶点，则称M是一个匹配。选择这样的边数最大的子集称为图的最大匹配问题,最大匹配的边数称为最大匹配数.如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。如果在左右两边加上源汇点后，图G等价于一个网络流，最大匹配问题可以转为最大流的问题。解决此问的匈牙利算法的本质就是寻找最大流的增广路径。  \n\n模板如下\n```c++\n/*\n    匈牙利算法\n    解决最大匹配问题\n    临接表版本\n*/\nstruct edge{\n    int to,next;\n}edge[MAXN];\nint head[MAXN],tot;\nvoid init()\n{\n    tot = 0;\n    memset(head,-1,sizeof(head));\n}\n\nvoid addedge(int u,int v)\n{\n    edge[tot].to = v;   edge[tot].next = head[u];\n    head[u] = tot++;\n}\nint linker[MAXN];\nint used[MAXN];\nint uN;         //点的编号0~uN-1\n\nbool dfs(int u)\n{\n    for(int i=head[u]; i!=-1; i=edge[i].next)\n    {\n        int v = edge[i].to;\n        if(!used[v])\n        {\n            used[v] = true;\n            if(linker[v]==-1 || dfs(linker[v])){\n                linker[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(linker,-1,sizeof(linker));\n    for(itn u=0; u<uN; u++){\n        memset(used,false,sizeof(used));\n        if(dfs(u))  res++;\n    }\n    return res;\n}\n\n/*\n邻接矩阵的匈牙利算法\n最小点覆盖等价于最大匹配，对每一个X集合未覆盖点出发进行一次匈牙利树扩展（dfs（））最后X内未标记和Y内已标记的集合组成最小覆盖\nmin_cover用来通过扩展匈牙利树寻找最小点覆盖\n*/\nint R,C,N;\nint uN,vN;\nint G[MAXN][MAXN];\nint Left[MAXN];\nint Right[MAXN];\nbool S[MAXN],T[MAXN];\n\nbool dfs(int u)\n{\n    S[u] = true;\n    for(int v=1; v<=vN;v++)\n    if(G[u][v] && !T[v]){\n        T[v] = true;\n        if(Left[v] == -1 || dfs(Left[v])){\n            Right[u] = v;\n            Left[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(Left,-1,sizeof(Left));\n    memset(Right,-1,sizeof(Right));\n    for(int u=1; u<=uN; u++){\n        memset(T,0,sizeof(T));\n        if(dfs(u)) res++;\n    }\n    return res;\n}\n\nint min_cover(vector<int> &X,vector<int> &Y)\n{\n    int ans = hungary();\n    X.clear();  Y.clear();\n    memset(S,0,sizeof(S));\n    memset(T,0,sizeof(T));\n    for(int i=1;i<=uN;i++)\n        if(Right[i]==-1) dfs(i);\n    for(int i=1;i<=uN;i++)\n        if(!S[i]) X.pb(i);\n    for(int j=1;j<=vN;j++)\n        if(T[j]) Y.pb(j);\n    return ans;\n}\n```\n\n\n## 二分图的一些特有性质\n### 最小覆盖\n1. **最小定点覆盖**:  \n    最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联，二分图的最小顶点覆盖数=二分图的最大匹配数。  \n**最小定点覆盖的证明**：  \n首先，最小点集覆盖一定>=最大匹配，因为假设最大匹配为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就要用到n个点。现在我们来思考为什么最小点击覆盖一定<=最大匹配。任何一种n个点的最小点击覆盖，一定可以转化成一个n的最大匹配。因为最小点集覆盖中的每个点都能找到至少一条只有一个端点在点集中的边（如果找不到则说明该点所有的边的另外一个端点都被覆盖，所以该点则没必要被覆盖，和它在最小点集覆盖中相矛盾），只要每个端点都选择一个这样的边，就必然能转化为一个匹配数与点集覆盖的点数相等的匹配方案。所以最大匹配至少为最小点集覆盖数，即最小点击覆盖一定<=最大匹配。综上，二者相等。\n\n2. **最小边覆盖**：  \n    最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图的最小路径覆盖数=|V|-二分图的最大匹配数。  \n    **最小边覆盖的证明**：  \n不妨设最小定点覆盖为X一共V个点，那么，最小边覆盖一定》=V-X。原因在于，首先根据最小点覆盖覆盖所有边的性质，最小点覆盖没取到的V-X条边两两无边相连，**也就是说他们是一个独立子集**，那么最小边覆盖要取到所有点的话就需要这V-X个点每个点取一条边。同时V-X又是取得到的，由于原图最小顶点覆盖就是最大二分匹配，每次取边的是后总是遵循是匹配边的话取匹配边，否则任取。那么结果一定取到了所有定点 \n\n\n\n**从二分最大匹配找到最小点覆盖**    \n需要借助匈牙利树： 设二分图两个集合为X Y  \n从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖\n\n### 最大独立集\n**最大独立集=V-最小覆盖集=V-最大匹配**  \n    \n    ![image](./二分图.png)\n    \n上图，我们用两个红色的点覆盖了所有边。我们证明的前提条件是已经达到最小覆盖。\n即条件1.已经覆盖所有边，条件2.所用的点数最小  \n**首先我们来证明蓝色点组成的是一个独立集：**   \n如果有两个蓝色点间有边相连，那么这条边则没有被覆盖，则与条件1矛盾。因此是独立集。  \n**再来证明这个独立集最大：**  \n如果我们要再增加这个独立集中的点，则需要把某个红点变成蓝点。而由最小覆盖数=最大匹配数的证明我们知道，每一个红点是最大匹配中的一个匹配点，也就是说每个红点至少连接了一条边。因此当我们将某个红点变成蓝点时，我们需要牺牲的蓝点的个数是大于等于1的。也就是说，我们最多只能找到数量相等的其他独立集，而无法找到数量更大的。因此蓝色点集必定为最大独立集。 蓝色点数 =总点数 - 红色点数，即最大独立集=总数-最小覆盖集。\n\n    ","slug":"acm/markdown/图论/二分图","published":1,"updated":"2017-08-27T11:46:36.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoeck1000quowo60hubzf5","content":"<h1 id=\"二分图最大匹配\"><a href=\"#二分图最大匹配\" class=\"headerlink\" title=\"二分图最大匹配\"></a>二分图最大匹配</h1><h2 id=\"最大匹配的匈牙利算法\"><a href=\"#最大匹配的匈牙利算法\" class=\"headerlink\" title=\"最大匹配的匈牙利算法\"></a>最大匹配的匈牙利算法</h2><h3 id=\"最大匹配：\"><a href=\"#最大匹配：\" class=\"headerlink\" title=\"最大匹配：\"></a>最大匹配：</h3><p>在G的一个子图M中，M的边集中的任意两条边都不依附于 同一个顶点，则称M是一个匹配。选择这样的边数最大的子集称为图的最大匹配问题,最大匹配的边数称为最大匹配数.如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。如果在左右两边加上源汇点后，图G等价于一个网络流，最大匹配问题可以转为最大流的问题。解决此问的匈牙利算法的本质就是寻找最大流的增广路径。  </p>\n<p>模板如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">    匈牙利算法</div><div class=\"line\">    解决最大匹配问题</div><div class=\"line\">    临接表版本</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">struct</span> edge&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> to,next;</div><div class=\"line\">&#125;edge[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> head[MAXN],tot;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    tot = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    edge[tot].to = v;   edge[tot].next = head[u];</div><div class=\"line\">    head[u] = tot++;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">int</span> linker[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> used[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> uN;         <span class=\"comment\">//点的编号0~uN-1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[u]; i!=<span class=\"number\">-1</span>; i=edge[i].next)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].to;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!used[v])</div><div class=\"line\">        &#123;</div><div class=\"line\">            used[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>(linker[v]==<span class=\"number\">-1</span> || dfs(linker[v]))&#123;</div><div class=\"line\">                linker[v] = u;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hungary</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(linker,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(linker));</div><div class=\"line\">    <span class=\"keyword\">for</span>(itn u=<span class=\"number\">0</span>; u&lt;uN; u++)&#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(used,<span class=\"literal\">false</span>,<span class=\"keyword\">sizeof</span>(used));</div><div class=\"line\">        <span class=\"keyword\">if</span>(dfs(u))  res++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">邻接矩阵的匈牙利算法</div><div class=\"line\">最小点覆盖等价于最大匹配，对每一个X集合未覆盖点出发进行一次匈牙利树扩展（dfs（））最后X内未标记和Y内已标记的集合组成最小覆盖</div><div class=\"line\">min_cover用来通过扩展匈牙利树寻找最小点覆盖</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">int</span> R,C,N;</div><div class=\"line\"><span class=\"keyword\">int</span> uN,vN;</div><div class=\"line\"><span class=\"keyword\">int</span> G[MAXN][MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Left[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Right[MAXN];</div><div class=\"line\"><span class=\"keyword\">bool</span> S[MAXN],T[MAXN];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    S[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v=<span class=\"number\">1</span>; v&lt;=vN;v++)</div><div class=\"line\">    <span class=\"keyword\">if</span>(G[u][v] &amp;&amp; !T[v])&#123;</div><div class=\"line\">        T[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(Left[v] == <span class=\"number\">-1</span> || dfs(Left[v]))&#123;</div><div class=\"line\">            Right[u] = v;</div><div class=\"line\">            Left[v] = u;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hungary</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Left,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Left));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Right,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Right));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u=<span class=\"number\">1</span>; u&lt;=uN; u++)&#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">        <span class=\"keyword\">if</span>(dfs(u)) res++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cover</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;X,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Y)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = hungary();</div><div class=\"line\">    X.clear();  Y.clear();</div><div class=\"line\">    <span class=\"built_in\">memset</span>(S,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(S));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(Right[i]==<span class=\"number\">-1</span>) dfs(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(!S[i]) X.pb(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=vN;j++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(T[j]) Y.pb(j);</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二分图的一些特有性质\"><a href=\"#二分图的一些特有性质\" class=\"headerlink\" title=\"二分图的一些特有性质\"></a>二分图的一些特有性质</h2><h3 id=\"最小覆盖\"><a href=\"#最小覆盖\" class=\"headerlink\" title=\"最小覆盖\"></a>最小覆盖</h3><ol>\n<li><p><strong>最小定点覆盖</strong>:<br> 最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联，二分图的最小顶点覆盖数=二分图的最大匹配数。<br><strong>最小定点覆盖的证明</strong>：<br>首先，最小点集覆盖一定&gt;=最大匹配，因为假设最大匹配为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就要用到n个点。现在我们来思考为什么最小点击覆盖一定&lt;=最大匹配。任何一种n个点的最小点击覆盖，一定可以转化成一个n的最大匹配。因为最小点集覆盖中的每个点都能找到至少一条只有一个端点在点集中的边（如果找不到则说明该点所有的边的另外一个端点都被覆盖，所以该点则没必要被覆盖，和它在最小点集覆盖中相矛盾），只要每个端点都选择一个这样的边，就必然能转化为一个匹配数与点集覆盖的点数相等的匹配方案。所以最大匹配至少为最小点集覆盖数，即最小点击覆盖一定&lt;=最大匹配。综上，二者相等。</p>\n</li>\n<li><p><strong>最小边覆盖</strong>：<br> 最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图的最小路径覆盖数=|V|-二分图的最大匹配数。<br> <strong>最小边覆盖的证明</strong>：<br>不妨设最小定点覆盖为X一共V个点，那么，最小边覆盖一定》=V-X。原因在于，首先根据最小点覆盖覆盖所有边的性质，最小点覆盖没取到的V-X条边两两无边相连，<strong>也就是说他们是一个独立子集</strong>，那么最小边覆盖要取到所有点的话就需要这V-X个点每个点取一条边。同时V-X又是取得到的，由于原图最小顶点覆盖就是最大二分匹配，每次取边的是后总是遵循是匹配边的话取匹配边，否则任取。那么结果一定取到了所有定点 </p>\n</li>\n</ol>\n<p><strong>从二分最大匹配找到最小点覆盖</strong><br>需要借助匈牙利树： 设二分图两个集合为X Y<br>从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖</p>\n<h3 id=\"最大独立集\"><a href=\"#最大独立集\" class=\"headerlink\" title=\"最大独立集\"></a>最大独立集</h3><p><strong>最大独立集=V-最小覆盖集=V-最大匹配</strong>  </p>\n<pre><code>![image](./二分图.png)\n</code></pre><p>上图，我们用两个红色的点覆盖了所有边。我们证明的前提条件是已经达到最小覆盖。<br>即条件1.已经覆盖所有边，条件2.所用的点数最小<br><strong>首先我们来证明蓝色点组成的是一个独立集：</strong><br>如果有两个蓝色点间有边相连，那么这条边则没有被覆盖，则与条件1矛盾。因此是独立集。<br><strong>再来证明这个独立集最大：</strong><br>如果我们要再增加这个独立集中的点，则需要把某个红点变成蓝点。而由最小覆盖数=最大匹配数的证明我们知道，每一个红点是最大匹配中的一个匹配点，也就是说每个红点至少连接了一条边。因此当我们将某个红点变成蓝点时，我们需要牺牲的蓝点的个数是大于等于1的。也就是说，我们最多只能找到数量相等的其他独立集，而无法找到数量更大的。因此蓝色点集必定为最大独立集。 蓝色点数 =总点数 - 红色点数，即最大独立集=总数-最小覆盖集。</p>\n","excerpt":"","more":"<h1 id=\"二分图最大匹配\"><a href=\"#二分图最大匹配\" class=\"headerlink\" title=\"二分图最大匹配\"></a>二分图最大匹配</h1><h2 id=\"最大匹配的匈牙利算法\"><a href=\"#最大匹配的匈牙利算法\" class=\"headerlink\" title=\"最大匹配的匈牙利算法\"></a>最大匹配的匈牙利算法</h2><h3 id=\"最大匹配：\"><a href=\"#最大匹配：\" class=\"headerlink\" title=\"最大匹配：\"></a>最大匹配：</h3><p>在G的一个子图M中，M的边集中的任意两条边都不依附于 同一个顶点，则称M是一个匹配。选择这样的边数最大的子集称为图的最大匹配问题,最大匹配的边数称为最大匹配数.如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。如果在左右两边加上源汇点后，图G等价于一个网络流，最大匹配问题可以转为最大流的问题。解决此问的匈牙利算法的本质就是寻找最大流的增广路径。  </p>\n<p>模板如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">    匈牙利算法</div><div class=\"line\">    解决最大匹配问题</div><div class=\"line\">    临接表版本</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"keyword\">struct</span> edge&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> to,next;</div><div class=\"line\">&#125;edge[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> head[MAXN],tot;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    tot = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(head));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    edge[tot].to = v;   edge[tot].next = head[u];</div><div class=\"line\">    head[u] = tot++;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">int</span> linker[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> used[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> uN;         <span class=\"comment\">//点的编号0~uN-1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[u]; i!=<span class=\"number\">-1</span>; i=edge[i].next)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> v = edge[i].to;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!used[v])</div><div class=\"line\">        &#123;</div><div class=\"line\">            used[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>(linker[v]==<span class=\"number\">-1</span> || dfs(linker[v]))&#123;</div><div class=\"line\">                linker[v] = u;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hungary</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(linker,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(linker));</div><div class=\"line\">    <span class=\"keyword\">for</span>(itn u=<span class=\"number\">0</span>; u&lt;uN; u++)&#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(used,<span class=\"literal\">false</span>,<span class=\"keyword\">sizeof</span>(used));</div><div class=\"line\">        <span class=\"keyword\">if</span>(dfs(u))  res++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">邻接矩阵的匈牙利算法</div><div class=\"line\">最小点覆盖等价于最大匹配，对每一个X集合未覆盖点出发进行一次匈牙利树扩展（dfs（））最后X内未标记和Y内已标记的集合组成最小覆盖</div><div class=\"line\">min_cover用来通过扩展匈牙利树寻找最小点覆盖</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"keyword\">int</span> R,C,N;</div><div class=\"line\"><span class=\"keyword\">int</span> uN,vN;</div><div class=\"line\"><span class=\"keyword\">int</span> G[MAXN][MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Left[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Right[MAXN];</div><div class=\"line\"><span class=\"keyword\">bool</span> S[MAXN],T[MAXN];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    S[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v=<span class=\"number\">1</span>; v&lt;=vN;v++)</div><div class=\"line\">    <span class=\"keyword\">if</span>(G[u][v] &amp;&amp; !T[v])&#123;</div><div class=\"line\">        T[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(Left[v] == <span class=\"number\">-1</span> || dfs(Left[v]))&#123;</div><div class=\"line\">            Right[u] = v;</div><div class=\"line\">            Left[v] = u;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hungary</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Left,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Left));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Right,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Right));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u=<span class=\"number\">1</span>; u&lt;=uN; u++)&#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">        <span class=\"keyword\">if</span>(dfs(u)) res++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cover</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;X,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Y)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = hungary();</div><div class=\"line\">    X.clear();  Y.clear();</div><div class=\"line\">    <span class=\"built_in\">memset</span>(S,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(S));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(Right[i]==<span class=\"number\">-1</span>) dfs(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(!S[i]) X.pb(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=vN;j++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(T[j]) Y.pb(j);</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"二分图的一些特有性质\"><a href=\"#二分图的一些特有性质\" class=\"headerlink\" title=\"二分图的一些特有性质\"></a>二分图的一些特有性质</h2><h3 id=\"最小覆盖\"><a href=\"#最小覆盖\" class=\"headerlink\" title=\"最小覆盖\"></a>最小覆盖</h3><ol>\n<li><p><strong>最小定点覆盖</strong>:<br> 最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联，二分图的最小顶点覆盖数=二分图的最大匹配数。<br><strong>最小定点覆盖的证明</strong>：<br>首先，最小点集覆盖一定&gt;=最大匹配，因为假设最大匹配为n，那么我们就得到了n条互不相邻的边，光覆盖这些边就要用到n个点。现在我们来思考为什么最小点击覆盖一定&lt;=最大匹配。任何一种n个点的最小点击覆盖，一定可以转化成一个n的最大匹配。因为最小点集覆盖中的每个点都能找到至少一条只有一个端点在点集中的边（如果找不到则说明该点所有的边的另外一个端点都被覆盖，所以该点则没必要被覆盖，和它在最小点集覆盖中相矛盾），只要每个端点都选择一个这样的边，就必然能转化为一个匹配数与点集覆盖的点数相等的匹配方案。所以最大匹配至少为最小点集覆盖数，即最小点击覆盖一定&lt;=最大匹配。综上，二者相等。</p>\n</li>\n<li><p><strong>最小边覆盖</strong>：<br> 最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图的最小路径覆盖数=|V|-二分图的最大匹配数。<br> <strong>最小边覆盖的证明</strong>：<br>不妨设最小定点覆盖为X一共V个点，那么，最小边覆盖一定》=V-X。原因在于，首先根据最小点覆盖覆盖所有边的性质，最小点覆盖没取到的V-X条边两两无边相连，<strong>也就是说他们是一个独立子集</strong>，那么最小边覆盖要取到所有点的话就需要这V-X个点每个点取一条边。同时V-X又是取得到的，由于原图最小顶点覆盖就是最大二分匹配，每次取边的是后总是遵循是匹配边的话取匹配边，否则任取。那么结果一定取到了所有定点 </p>\n</li>\n</ol>\n<p><strong>从二分最大匹配找到最小点覆盖</strong><br>需要借助匈牙利树： 设二分图两个集合为X Y<br>从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖</p>\n<h3 id=\"最大独立集\"><a href=\"#最大独立集\" class=\"headerlink\" title=\"最大独立集\"></a>最大独立集</h3><p><strong>最大独立集=V-最小覆盖集=V-最大匹配</strong>  </p>\n<pre><code>![image](./二分图.png)\n</code></pre><p>上图，我们用两个红色的点覆盖了所有边。我们证明的前提条件是已经达到最小覆盖。<br>即条件1.已经覆盖所有边，条件2.所用的点数最小<br><strong>首先我们来证明蓝色点组成的是一个独立集：</strong><br>如果有两个蓝色点间有边相连，那么这条边则没有被覆盖，则与条件1矛盾。因此是独立集。<br><strong>再来证明这个独立集最大：</strong><br>如果我们要再增加这个独立集中的点，则需要把某个红点变成蓝点。而由最小覆盖数=最大匹配数的证明我们知道，每一个红点是最大匹配中的一个匹配点，也就是说每个红点至少连接了一条边。因此当我们将某个红点变成蓝点时，我们需要牺牲的蓝点的个数是大于等于1的。也就是说，我们最多只能找到数量相等的其他独立集，而无法找到数量更大的。因此蓝色点集必定为最大独立集。 蓝色点数 =总点数 - 红色点数，即最大独立集=总数-最小覆盖集。</p>\n"},{"title":"Uva-11354 最小瓶颈树+LCA倍增法维护最大值","date":"2017-08-27T04:03:34.000Z","_content":"\n# Uva-11354\n题意：  \n给你一个无向图，N个节点M条边，边权为d，对Q组询问a b,问能取到的从a到b路径上的最小值。\n\n题解：  \n首先总是要取最小的值，则可以先用kruskal求最小生成树（也就是最小瓶颈树），即在树上求任意两点之间路径边权值的最小值。可以用倍增求解LCA的方法，**在保存p[i][j]（节点i的向上2^i个祖先） 的同时维护mlen[i][j]（节点i向上2^i条边的最大值）**\n\n```c++\n    #include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define pb push_back\n#define mk make_pair\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define mkp make_pair\n#define fst first\n#define scd second\n#define ALL(A) A.begin(), A.end()\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REP1(i, n) for(int (i)=1;(i)<=(int)(n);(i)++)\n#define fastio ios::sync_with_stdio(0), cin.tie(0)\n#define frein freopen(\"in.txt\", \"r\", stdin)\n#define freout freopen(\"out.txt\", \"w\", stdout)\n#define freout1 freopen(\"out1.txt\", \"w\", stdout)\n#define PI M_PI\n#define MAXN 100000\n#define xork(a,b) ((b&1)?(a):(0))\n#define sc(n) scanf(\"%d\",&(n))\n\nll mod = 10000;\nll INF = 1LL<<60LL;\nconst double eps = 1e-8;\ntemplate<typename T> T gcd(T a,T b)\n{if(!b)return a;return gcd(b,a%b);}\nstruct edge{\n    int from,to;\n    int v;\n    bool operator<(const edge &a)const{\n        return v<a.v;\n    }\n};\n\nvector<edge> E;\nvector<vector<pii> >G(MAXN);\nint d[MAXN],len[MAXN];\nint p[MAXN][20],mlen[MAXN][20];\nint f[MAXN];\nint N,M;\n\nint getf(int v){\n    if(f[v]==v) return v;\n    else return f[v] = getf(f[v]);\n}\n\nbool Merge(int v1,int v2){\n    int f1 = getf(v1);\n    int f2 = getf(v2);\n    if(f1 == f2){\n        return false;\n    }\n    f[f1] = f2;\n    return true;\n}\n\nvoid kruskal()\n{\n    for(int i=0; i<=N; i++)\n        f[i] = i;\n    int cnt = 0;\n    for(int i=0; i<E.size(); i++){\n        if(cnt>=N-1)    break;\n        int f = E[i].from;\n        int t = E[i].to;\n        if(Merge(f,t)){\n            cnt++;\n            G[f].pb(mkp(t,E[i].v));\n            G[t].pb(mkp(f,E[i].v));\n//            cout<<f<<\" \"<<t<<\" \"<<E[i].v<<endl;\n        }\n    }\n}\n\nvoid dfs(int v,int pre,int depth)\n{\n    d[v] = depth;\n    for(int i=0; i<G[v].size(); i++){\n        int t = G[v][i].first;\n        int val = G[v][i].second;\n        if(t==pre)  continue;\n        dfs(t,v,depth+1);\n        //len[t] = val;\n        p[t][0] = v;\n        mlen[t][0] = val;\n    }\n}\n\nvoid lca_init(int n)\n{\n//    for(int i=1; i<=n; i++)\n//        printf(\"mlen[%d][0] = %d\\n\",i,mlen[i][0]);\n    for(int j=1; (1<<j)<=n; j++){\n        for(int i=1; i<=n; i++){\n            p[i][j] = p[p[i][j-1]][j-1];\n            mlen[i][j] = max(mlen[i][j-1],mlen[p[i][j-1]][j-1]);\n            //printf(\"mlen[%d][%d] = %d\\n\",i,j,mlen[i][j]);\n        }\n    }\n}\n\nint query(int a,int b)\n{\n    //printf(\"Query a:%d b%d\\n\",a,b);\n    if(d[a]>d[b])  swap(a,b);\n    int f = d[b] - d[a];\n    int maxe = -1;\n    for(int i=0; (1<<i)<=f; i++)\n        if(f&(1<<i)){\n            maxe = max(maxe,mlen[b][i]);\n            b = p[b][i];\n        }\n    //printf(\"maxe = %d\\n\",maxe);\n    if(a!=b){\n        for(int i=(int)log2(N);i>=0; i--){\n            if(p[a][i]!=p[b][i]){\n                maxe = max(maxe,max(mlen[b][i],mlen[a][i]));\n                a = p[a][i];    b = p[b][i];\n            }\n            //printf(\"maxe = %d\\n\",maxe);\n        }\n        maxe = max(maxe,mlen[a][0]);    //和求LCA不同，这里要同时对两个节点更新最大值\n        maxe = max(maxe,mlen[b][0]);\n        //printf(\"a = %d  maxe = %d\\n\",a,maxe);\n    }\n    return maxe;\n}\n\nint main()\n{\n    //freout;\n    bool flag = false;\n    while(~scanf(\"%d%d\",&N,&M)){\n        if(flag) puts(\"\");\n        flag = true;\n        E.clear();\n        for(int i=1; i<=N; i++)\n            G[i].clear();\n        for(int i=0; i<M; i++){\n            edge t;\n            scanf(\"%d%d%d\",&t.from,&t.to,&t.v);\n            E.pb(t);\n        }\n        sort(E.begin(),E.end());\n        kruskal();\n        dfs(1,-1,0);\n        lca_init(N);\n        int Q;\n        sc(Q);\n        for(int i=0; i<Q; i++){\n            int a,b;\n            sc(a); sc(b);\n            printf(\"%d\\n\",query(a,b));\n        }\n    }\n}\n\n```","source":"_posts/acm/题解/图论/Uva-11354 最小瓶颈树+LCA倍增法维护最大值.md","raw":"---\ntitle: Uva-11354 最小瓶颈树+LCA倍增法维护最大值\ndate: 2017-8-27 12:03:34\ncategories: ACM\ntags:  [最小瓶颈树,kruskal,倍增法,LCA]\n---\n\n# Uva-11354\n题意：  \n给你一个无向图，N个节点M条边，边权为d，对Q组询问a b,问能取到的从a到b路径上的最小值。\n\n题解：  \n首先总是要取最小的值，则可以先用kruskal求最小生成树（也就是最小瓶颈树），即在树上求任意两点之间路径边权值的最小值。可以用倍增求解LCA的方法，**在保存p[i][j]（节点i的向上2^i个祖先） 的同时维护mlen[i][j]（节点i向上2^i条边的最大值）**\n\n```c++\n    #include <iostream>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define pb push_back\n#define mk make_pair\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define mkp make_pair\n#define fst first\n#define scd second\n#define ALL(A) A.begin(), A.end()\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define REP1(i, n) for(int (i)=1;(i)<=(int)(n);(i)++)\n#define fastio ios::sync_with_stdio(0), cin.tie(0)\n#define frein freopen(\"in.txt\", \"r\", stdin)\n#define freout freopen(\"out.txt\", \"w\", stdout)\n#define freout1 freopen(\"out1.txt\", \"w\", stdout)\n#define PI M_PI\n#define MAXN 100000\n#define xork(a,b) ((b&1)?(a):(0))\n#define sc(n) scanf(\"%d\",&(n))\n\nll mod = 10000;\nll INF = 1LL<<60LL;\nconst double eps = 1e-8;\ntemplate<typename T> T gcd(T a,T b)\n{if(!b)return a;return gcd(b,a%b);}\nstruct edge{\n    int from,to;\n    int v;\n    bool operator<(const edge &a)const{\n        return v<a.v;\n    }\n};\n\nvector<edge> E;\nvector<vector<pii> >G(MAXN);\nint d[MAXN],len[MAXN];\nint p[MAXN][20],mlen[MAXN][20];\nint f[MAXN];\nint N,M;\n\nint getf(int v){\n    if(f[v]==v) return v;\n    else return f[v] = getf(f[v]);\n}\n\nbool Merge(int v1,int v2){\n    int f1 = getf(v1);\n    int f2 = getf(v2);\n    if(f1 == f2){\n        return false;\n    }\n    f[f1] = f2;\n    return true;\n}\n\nvoid kruskal()\n{\n    for(int i=0; i<=N; i++)\n        f[i] = i;\n    int cnt = 0;\n    for(int i=0; i<E.size(); i++){\n        if(cnt>=N-1)    break;\n        int f = E[i].from;\n        int t = E[i].to;\n        if(Merge(f,t)){\n            cnt++;\n            G[f].pb(mkp(t,E[i].v));\n            G[t].pb(mkp(f,E[i].v));\n//            cout<<f<<\" \"<<t<<\" \"<<E[i].v<<endl;\n        }\n    }\n}\n\nvoid dfs(int v,int pre,int depth)\n{\n    d[v] = depth;\n    for(int i=0; i<G[v].size(); i++){\n        int t = G[v][i].first;\n        int val = G[v][i].second;\n        if(t==pre)  continue;\n        dfs(t,v,depth+1);\n        //len[t] = val;\n        p[t][0] = v;\n        mlen[t][0] = val;\n    }\n}\n\nvoid lca_init(int n)\n{\n//    for(int i=1; i<=n; i++)\n//        printf(\"mlen[%d][0] = %d\\n\",i,mlen[i][0]);\n    for(int j=1; (1<<j)<=n; j++){\n        for(int i=1; i<=n; i++){\n            p[i][j] = p[p[i][j-1]][j-1];\n            mlen[i][j] = max(mlen[i][j-1],mlen[p[i][j-1]][j-1]);\n            //printf(\"mlen[%d][%d] = %d\\n\",i,j,mlen[i][j]);\n        }\n    }\n}\n\nint query(int a,int b)\n{\n    //printf(\"Query a:%d b%d\\n\",a,b);\n    if(d[a]>d[b])  swap(a,b);\n    int f = d[b] - d[a];\n    int maxe = -1;\n    for(int i=0; (1<<i)<=f; i++)\n        if(f&(1<<i)){\n            maxe = max(maxe,mlen[b][i]);\n            b = p[b][i];\n        }\n    //printf(\"maxe = %d\\n\",maxe);\n    if(a!=b){\n        for(int i=(int)log2(N);i>=0; i--){\n            if(p[a][i]!=p[b][i]){\n                maxe = max(maxe,max(mlen[b][i],mlen[a][i]));\n                a = p[a][i];    b = p[b][i];\n            }\n            //printf(\"maxe = %d\\n\",maxe);\n        }\n        maxe = max(maxe,mlen[a][0]);    //和求LCA不同，这里要同时对两个节点更新最大值\n        maxe = max(maxe,mlen[b][0]);\n        //printf(\"a = %d  maxe = %d\\n\",a,maxe);\n    }\n    return maxe;\n}\n\nint main()\n{\n    //freout;\n    bool flag = false;\n    while(~scanf(\"%d%d\",&N,&M)){\n        if(flag) puts(\"\");\n        flag = true;\n        E.clear();\n        for(int i=1; i<=N; i++)\n            G[i].clear();\n        for(int i=0; i<M; i++){\n            edge t;\n            scanf(\"%d%d%d\",&t.from,&t.to,&t.v);\n            E.pb(t);\n        }\n        sort(E.begin(),E.end());\n        kruskal();\n        dfs(1,-1,0);\n        lca_init(N);\n        int Q;\n        sc(Q);\n        for(int i=0; i<Q; i++){\n            int a,b;\n            sc(a); sc(b);\n            printf(\"%d\\n\",query(a,b));\n        }\n    }\n}\n\n```","slug":"acm/题解/图论/Uva-11354 最小瓶颈树+LCA倍增法维护最大值","published":1,"updated":"2017-08-27T11:49:41.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoeckk000suowod783zktp","content":"<h1 id=\"Uva-11354\"><a href=\"#Uva-11354\" class=\"headerlink\" title=\"Uva-11354\"></a>Uva-11354</h1><p>题意：<br>给你一个无向图，N个节点M条边，边权为d，对Q组询问a b,问能取到的从a到b路径上的最小值。</p>\n<p>题解：<br>首先总是要取最小的值，则可以先用kruskal求最小生成树（也就是最小瓶颈树），即在树上求任意两点之间路径边权值的最小值。可以用倍增求解LCA的方法，<strong>在保存p[i][j]（节点i的向上2^i个祖先） 的同时维护mlen[i][j]（节点i向上2^i条边的最大值）</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div></pre></td><td class=\"code\"><pre><div class=\"line\">    #include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdio&gt;</div><div class=\"line\">#include &lt;cctype&gt;</div><div class=\"line\">#include &lt;algorithm&gt;</div><div class=\"line\">#include &lt;cstring&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\">#include &lt;cmath&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;set&gt;</div><div class=\"line\">#include &lt;stack&gt;</div><div class=\"line\">#include &lt;sstream&gt;</div><div class=\"line\">#include &lt;queue&gt;</div><div class=\"line\">#include &lt;map&gt;</div><div class=\"line\">#include &lt;functional&gt;</div><div class=\"line\">#include &lt;bitset&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\">#define pb push_back</div><div class=\"line\">#define mk make_pair</div><div class=\"line\">#define ll long long</div><div class=\"line\">#define ull unsigned long long</div><div class=\"line\">#define pii pair&lt;int, int&gt;</div><div class=\"line\">#define mkp make_pair</div><div class=\"line\">#define fst first</div><div class=\"line\">#define scd second</div><div class=\"line\">#define ALL(A) A.begin(), A.end()</div><div class=\"line\">#define REP(i,n) for(int (i)=0;(i)&lt;(int)(n);(i)++)</div><div class=\"line\">#define REP1(i, n) for(int (i)=1;(i)&lt;=(int)(n);(i)++)</div><div class=\"line\">#define fastio ios::sync_with_stdio(0), cin.tie(0)</div><div class=\"line\">#define frein freopen(\"in.txt\", \"r\", stdin)</div><div class=\"line\">#define freout freopen(\"out.txt\", \"w\", stdout)</div><div class=\"line\">#define freout1 freopen(\"out1.txt\", \"w\", stdout)</div><div class=\"line\">#define PI M_PI</div><div class=\"line\">#define MAXN 100000</div><div class=\"line\">#define xork(a,b) ((b&amp;1)?(a):(0))</div><div class=\"line\">#define sc(n) scanf(\"%d\",&amp;(n))</div><div class=\"line\"></div><div class=\"line\">ll mod = 10000;</div><div class=\"line\">ll INF = 1LL&lt;&lt;60LL;</div><div class=\"line\">const double eps = 1e-8;</div><div class=\"line\">template&lt;typename T&gt; T gcd(T a,T b)</div><div class=\"line\">&#123;if(!b)return a;return gcd(b,a%b);&#125;</div><div class=\"line\">struct edge&#123;</div><div class=\"line\">    int from,to;</div><div class=\"line\">    int v;</div><div class=\"line\">    bool operator&lt;(const edge &amp;a)const&#123;</div><div class=\"line\">        return v&lt;a.v;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">vector&lt;edge&gt; E;</div><div class=\"line\">vector&lt;vector&lt;pii&gt; &gt;G(MAXN);</div><div class=\"line\">int d[MAXN],len[MAXN];</div><div class=\"line\">int p[MAXN][20],mlen[MAXN][20];</div><div class=\"line\">int f[MAXN];</div><div class=\"line\">int N,M;</div><div class=\"line\"></div><div class=\"line\">int getf(int v)&#123;</div><div class=\"line\">    if(f[v]==v) return v;</div><div class=\"line\">    else return f[v] = getf(f[v]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bool Merge(int v1,int v2)&#123;</div><div class=\"line\">    int f1 = getf(v1);</div><div class=\"line\">    int f2 = getf(v2);</div><div class=\"line\">    if(f1 == f2)&#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    f[f1] = f2;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void kruskal()</div><div class=\"line\">&#123;</div><div class=\"line\">    for(int i=0; i&lt;=N; i++)</div><div class=\"line\">        f[i] = i;</div><div class=\"line\">    int cnt = 0;</div><div class=\"line\">    for(int i=0; i&lt;E.size(); i++)&#123;</div><div class=\"line\">        if(cnt&gt;=N-1)    break;</div><div class=\"line\">        int f = E[i].from;</div><div class=\"line\">        int t = E[i].to;</div><div class=\"line\">        if(Merge(f,t))&#123;</div><div class=\"line\">            cnt++;</div><div class=\"line\">            G[f].pb(mkp(t,E[i].v));</div><div class=\"line\">            G[t].pb(mkp(f,E[i].v));</div><div class=\"line\">//            cout&lt;&lt;f&lt;&lt;\" \"&lt;&lt;t&lt;&lt;\" \"&lt;&lt;E[i].v&lt;&lt;endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void dfs(int v,int pre,int depth)</div><div class=\"line\">&#123;</div><div class=\"line\">    d[v] = depth;</div><div class=\"line\">    for(int i=0; i&lt;G[v].size(); i++)&#123;</div><div class=\"line\">        int t = G[v][i].first;</div><div class=\"line\">        int val = G[v][i].second;</div><div class=\"line\">        if(t==pre)  continue;</div><div class=\"line\">        dfs(t,v,depth+1);</div><div class=\"line\">        //len[t] = val;</div><div class=\"line\">        p[t][0] = v;</div><div class=\"line\">        mlen[t][0] = val;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void lca_init(int n)</div><div class=\"line\">&#123;</div><div class=\"line\">//    for(int i=1; i&lt;=n; i++)</div><div class=\"line\">//        printf(\"mlen[%d][0] = %d\\n\",i,mlen[i][0]);</div><div class=\"line\">    for(int j=1; (1&lt;&lt;j)&lt;=n; j++)&#123;</div><div class=\"line\">        for(int i=1; i&lt;=n; i++)&#123;</div><div class=\"line\">            p[i][j] = p[p[i][j-1]][j-1];</div><div class=\"line\">            mlen[i][j] = max(mlen[i][j-1],mlen[p[i][j-1]][j-1]);</div><div class=\"line\">            //printf(\"mlen[%d][%d] = %d\\n\",i,j,mlen[i][j]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int query(int a,int b)</div><div class=\"line\">&#123;</div><div class=\"line\">    //printf(\"Query a:%d b%d\\n\",a,b);</div><div class=\"line\">    if(d[a]&gt;d[b])  swap(a,b);</div><div class=\"line\">    int f = d[b] - d[a];</div><div class=\"line\">    int maxe = -1;</div><div class=\"line\">    for(int i=0; (1&lt;&lt;i)&lt;=f; i++)</div><div class=\"line\">        if(f&amp;(1&lt;&lt;i))&#123;</div><div class=\"line\">            maxe = max(maxe,mlen[b][i]);</div><div class=\"line\">            b = p[b][i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    //printf(\"maxe = %d\\n\",maxe);</div><div class=\"line\">    if(a!=b)&#123;</div><div class=\"line\">        for(int i=(int)log2(N);i&gt;=0; i--)&#123;</div><div class=\"line\">            if(p[a][i]!=p[b][i])&#123;</div><div class=\"line\">                maxe = max(maxe,max(mlen[b][i],mlen[a][i]));</div><div class=\"line\">                a = p[a][i];    b = p[b][i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            //printf(\"maxe = %d\\n\",maxe);</div><div class=\"line\">        &#125;</div><div class=\"line\">        maxe = max(maxe,mlen[a][0]);    //和求LCA不同，这里要同时对两个节点更新最大值</div><div class=\"line\">        maxe = max(maxe,mlen[b][0]);</div><div class=\"line\">        //printf(\"a = %d  maxe = %d\\n\",a,maxe);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return maxe;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    //freout;</div><div class=\"line\">    bool flag = false;</div><div class=\"line\">    while(~scanf(\"%d%d\",&amp;N,&amp;M))&#123;</div><div class=\"line\">        if(flag) puts(\"\");</div><div class=\"line\">        flag = true;</div><div class=\"line\">        E.clear();</div><div class=\"line\">        for(int i=1; i&lt;=N; i++)</div><div class=\"line\">            G[i].clear();</div><div class=\"line\">        for(int i=0; i&lt;M; i++)&#123;</div><div class=\"line\">            edge t;</div><div class=\"line\">            scanf(\"%d%d%d\",&amp;t.from,&amp;t.to,&amp;t.v);</div><div class=\"line\">            E.pb(t);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sort(E.begin(),E.end());</div><div class=\"line\">        kruskal();</div><div class=\"line\">        dfs(1,-1,0);</div><div class=\"line\">        lca_init(N);</div><div class=\"line\">        int Q;</div><div class=\"line\">        sc(Q);</div><div class=\"line\">        for(int i=0; i&lt;Q; i++)&#123;</div><div class=\"line\">            int a,b;</div><div class=\"line\">            sc(a); sc(b);</div><div class=\"line\">            printf(\"%d\\n\",query(a,b));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"Uva-11354\"><a href=\"#Uva-11354\" class=\"headerlink\" title=\"Uva-11354\"></a>Uva-11354</h1><p>题意：<br>给你一个无向图，N个节点M条边，边权为d，对Q组询问a b,问能取到的从a到b路径上的最小值。</p>\n<p>题解：<br>首先总是要取最小的值，则可以先用kruskal求最小生成树（也就是最小瓶颈树），即在树上求任意两点之间路径边权值的最小值。可以用倍增求解LCA的方法，<strong>在保存p[i][j]（节点i的向上2^i个祖先） 的同时维护mlen[i][j]（节点i向上2^i条边的最大值）</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div></pre></td><td class=\"code\"><pre><div class=\"line\">    #include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdio&gt;</div><div class=\"line\">#include &lt;cctype&gt;</div><div class=\"line\">#include &lt;algorithm&gt;</div><div class=\"line\">#include &lt;cstring&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\">#include &lt;cmath&gt;</div><div class=\"line\">#include &lt;vector&gt;</div><div class=\"line\">#include &lt;set&gt;</div><div class=\"line\">#include &lt;stack&gt;</div><div class=\"line\">#include &lt;sstream&gt;</div><div class=\"line\">#include &lt;queue&gt;</div><div class=\"line\">#include &lt;map&gt;</div><div class=\"line\">#include &lt;functional&gt;</div><div class=\"line\">#include &lt;bitset&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\">#define pb push_back</div><div class=\"line\">#define mk make_pair</div><div class=\"line\">#define ll long long</div><div class=\"line\">#define ull unsigned long long</div><div class=\"line\">#define pii pair&lt;int, int&gt;</div><div class=\"line\">#define mkp make_pair</div><div class=\"line\">#define fst first</div><div class=\"line\">#define scd second</div><div class=\"line\">#define ALL(A) A.begin(), A.end()</div><div class=\"line\">#define REP(i,n) for(int (i)=0;(i)&lt;(int)(n);(i)++)</div><div class=\"line\">#define REP1(i, n) for(int (i)=1;(i)&lt;=(int)(n);(i)++)</div><div class=\"line\">#define fastio ios::sync_with_stdio(0), cin.tie(0)</div><div class=\"line\">#define frein freopen(\"in.txt\", \"r\", stdin)</div><div class=\"line\">#define freout freopen(\"out.txt\", \"w\", stdout)</div><div class=\"line\">#define freout1 freopen(\"out1.txt\", \"w\", stdout)</div><div class=\"line\">#define PI M_PI</div><div class=\"line\">#define MAXN 100000</div><div class=\"line\">#define xork(a,b) ((b&amp;1)?(a):(0))</div><div class=\"line\">#define sc(n) scanf(\"%d\",&amp;(n))</div><div class=\"line\"></div><div class=\"line\">ll mod = 10000;</div><div class=\"line\">ll INF = 1LL&lt;&lt;60LL;</div><div class=\"line\">const double eps = 1e-8;</div><div class=\"line\">template&lt;typename T&gt; T gcd(T a,T b)</div><div class=\"line\">&#123;if(!b)return a;return gcd(b,a%b);&#125;</div><div class=\"line\">struct edge&#123;</div><div class=\"line\">    int from,to;</div><div class=\"line\">    int v;</div><div class=\"line\">    bool operator&lt;(const edge &amp;a)const&#123;</div><div class=\"line\">        return v&lt;a.v;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">vector&lt;edge&gt; E;</div><div class=\"line\">vector&lt;vector&lt;pii&gt; &gt;G(MAXN);</div><div class=\"line\">int d[MAXN],len[MAXN];</div><div class=\"line\">int p[MAXN][20],mlen[MAXN][20];</div><div class=\"line\">int f[MAXN];</div><div class=\"line\">int N,M;</div><div class=\"line\"></div><div class=\"line\">int getf(int v)&#123;</div><div class=\"line\">    if(f[v]==v) return v;</div><div class=\"line\">    else return f[v] = getf(f[v]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bool Merge(int v1,int v2)&#123;</div><div class=\"line\">    int f1 = getf(v1);</div><div class=\"line\">    int f2 = getf(v2);</div><div class=\"line\">    if(f1 == f2)&#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    f[f1] = f2;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void kruskal()</div><div class=\"line\">&#123;</div><div class=\"line\">    for(int i=0; i&lt;=N; i++)</div><div class=\"line\">        f[i] = i;</div><div class=\"line\">    int cnt = 0;</div><div class=\"line\">    for(int i=0; i&lt;E.size(); i++)&#123;</div><div class=\"line\">        if(cnt&gt;=N-1)    break;</div><div class=\"line\">        int f = E[i].from;</div><div class=\"line\">        int t = E[i].to;</div><div class=\"line\">        if(Merge(f,t))&#123;</div><div class=\"line\">            cnt++;</div><div class=\"line\">            G[f].pb(mkp(t,E[i].v));</div><div class=\"line\">            G[t].pb(mkp(f,E[i].v));</div><div class=\"line\">//            cout&lt;&lt;f&lt;&lt;\" \"&lt;&lt;t&lt;&lt;\" \"&lt;&lt;E[i].v&lt;&lt;endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void dfs(int v,int pre,int depth)</div><div class=\"line\">&#123;</div><div class=\"line\">    d[v] = depth;</div><div class=\"line\">    for(int i=0; i&lt;G[v].size(); i++)&#123;</div><div class=\"line\">        int t = G[v][i].first;</div><div class=\"line\">        int val = G[v][i].second;</div><div class=\"line\">        if(t==pre)  continue;</div><div class=\"line\">        dfs(t,v,depth+1);</div><div class=\"line\">        //len[t] = val;</div><div class=\"line\">        p[t][0] = v;</div><div class=\"line\">        mlen[t][0] = val;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void lca_init(int n)</div><div class=\"line\">&#123;</div><div class=\"line\">//    for(int i=1; i&lt;=n; i++)</div><div class=\"line\">//        printf(\"mlen[%d][0] = %d\\n\",i,mlen[i][0]);</div><div class=\"line\">    for(int j=1; (1&lt;&lt;j)&lt;=n; j++)&#123;</div><div class=\"line\">        for(int i=1; i&lt;=n; i++)&#123;</div><div class=\"line\">            p[i][j] = p[p[i][j-1]][j-1];</div><div class=\"line\">            mlen[i][j] = max(mlen[i][j-1],mlen[p[i][j-1]][j-1]);</div><div class=\"line\">            //printf(\"mlen[%d][%d] = %d\\n\",i,j,mlen[i][j]);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int query(int a,int b)</div><div class=\"line\">&#123;</div><div class=\"line\">    //printf(\"Query a:%d b%d\\n\",a,b);</div><div class=\"line\">    if(d[a]&gt;d[b])  swap(a,b);</div><div class=\"line\">    int f = d[b] - d[a];</div><div class=\"line\">    int maxe = -1;</div><div class=\"line\">    for(int i=0; (1&lt;&lt;i)&lt;=f; i++)</div><div class=\"line\">        if(f&amp;(1&lt;&lt;i))&#123;</div><div class=\"line\">            maxe = max(maxe,mlen[b][i]);</div><div class=\"line\">            b = p[b][i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    //printf(\"maxe = %d\\n\",maxe);</div><div class=\"line\">    if(a!=b)&#123;</div><div class=\"line\">        for(int i=(int)log2(N);i&gt;=0; i--)&#123;</div><div class=\"line\">            if(p[a][i]!=p[b][i])&#123;</div><div class=\"line\">                maxe = max(maxe,max(mlen[b][i],mlen[a][i]));</div><div class=\"line\">                a = p[a][i];    b = p[b][i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            //printf(\"maxe = %d\\n\",maxe);</div><div class=\"line\">        &#125;</div><div class=\"line\">        maxe = max(maxe,mlen[a][0]);    //和求LCA不同，这里要同时对两个节点更新最大值</div><div class=\"line\">        maxe = max(maxe,mlen[b][0]);</div><div class=\"line\">        //printf(\"a = %d  maxe = %d\\n\",a,maxe);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return maxe;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    //freout;</div><div class=\"line\">    bool flag = false;</div><div class=\"line\">    while(~scanf(\"%d%d\",&amp;N,&amp;M))&#123;</div><div class=\"line\">        if(flag) puts(\"\");</div><div class=\"line\">        flag = true;</div><div class=\"line\">        E.clear();</div><div class=\"line\">        for(int i=1; i&lt;=N; i++)</div><div class=\"line\">            G[i].clear();</div><div class=\"line\">        for(int i=0; i&lt;M; i++)&#123;</div><div class=\"line\">            edge t;</div><div class=\"line\">            scanf(\"%d%d%d\",&amp;t.from,&amp;t.to,&amp;t.v);</div><div class=\"line\">            E.pb(t);</div><div class=\"line\">        &#125;</div><div class=\"line\">        sort(E.begin(),E.end());</div><div class=\"line\">        kruskal();</div><div class=\"line\">        dfs(1,-1,0);</div><div class=\"line\">        lca_init(N);</div><div class=\"line\">        int Q;</div><div class=\"line\">        sc(Q);</div><div class=\"line\">        for(int i=0; i&lt;Q; i++)&#123;</div><div class=\"line\">            int a,b;</div><div class=\"line\">            sc(a); sc(b);</div><div class=\"line\">            printf(\"%d\\n\",query(a,b));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"稀疏表","date":"2017-08-20T04:03:34.000Z","_content":"\n## Spared Table （用于解决多种RMQ问题）\n模板：\n（解决区间极小值）\n```c++\n/*\nST用来O（nlogn）时间预处理，O（1）时间查询最大最小值\n*/\n#include <iostream>  \n#include <math.h>  \nusing namespace std;  \n  \n/*方程 \nF[i,j]:区间[i,i + 2^j - 1]的最小值，此时区间长度为2^j \nF[i,j] = min(F[i,j - 1],F[i + 2^(j - 1),j - 1]) \nF[i,0] = nArr[i];*/  \n  \nconst int MAXN = 10010;\nint rmq[2*MAXN];//rmq数组,就是欧拉序列对应的深度序列\n  \nstruct ST\n{\n    int mm[2*MAXN];//意思是向下取log2(k)\n    int dp[2*MAXN][20];//最小值对应的下标\n    void init(int n)\n    {\n        mm[0] = -1;\n        for(int i = 1;i <= n;i++)\n        {\n            mm[i] = ((i&(i-1)) == 0)?mm[i-1]+1:mm[i-1];\n            dp[i][0] = i;\n        }\n        for(int j = 1; j <= mm[n];j++)\n            for(int i = 1; i + (1<<j) - 1 <= n; i++)\n                dp[i][j] = rmq[dp[i][j-1]] <\n                rmq[dp[i+(1<<(j-1))][j-1]]?dp[i][j-1]:dp[i+(1<<(j-1))][j-1];\n    }\n    int query(int a,int b)//查询[a,b]之间最小值的下标\n    {\n        if(a > b)swap(a,b);\n        int k = mm[b-a+1];\n        return rmq[dp[a][k]] <= \n        rmq[dp[b-(1<<k)+1][k]]?dp[a][k]:dp[b-(1<<k)+1][k];\n    }\n};\n```\n\n例：hdu-5726 解决区间最小公倍数\n","source":"_posts/acm/markdown/数据结构/稀疏表.md","raw":"---\ntitle: 稀疏表\ndate: 2017-8-20 12:03:34\ncategories: ACM\ntags:  [RMQ,稀疏表]\n---\n\n## Spared Table （用于解决多种RMQ问题）\n模板：\n（解决区间极小值）\n```c++\n/*\nST用来O（nlogn）时间预处理，O（1）时间查询最大最小值\n*/\n#include <iostream>  \n#include <math.h>  \nusing namespace std;  \n  \n/*方程 \nF[i,j]:区间[i,i + 2^j - 1]的最小值，此时区间长度为2^j \nF[i,j] = min(F[i,j - 1],F[i + 2^(j - 1),j - 1]) \nF[i,0] = nArr[i];*/  \n  \nconst int MAXN = 10010;\nint rmq[2*MAXN];//rmq数组,就是欧拉序列对应的深度序列\n  \nstruct ST\n{\n    int mm[2*MAXN];//意思是向下取log2(k)\n    int dp[2*MAXN][20];//最小值对应的下标\n    void init(int n)\n    {\n        mm[0] = -1;\n        for(int i = 1;i <= n;i++)\n        {\n            mm[i] = ((i&(i-1)) == 0)?mm[i-1]+1:mm[i-1];\n            dp[i][0] = i;\n        }\n        for(int j = 1; j <= mm[n];j++)\n            for(int i = 1; i + (1<<j) - 1 <= n; i++)\n                dp[i][j] = rmq[dp[i][j-1]] <\n                rmq[dp[i+(1<<(j-1))][j-1]]?dp[i][j-1]:dp[i+(1<<(j-1))][j-1];\n    }\n    int query(int a,int b)//查询[a,b]之间最小值的下标\n    {\n        if(a > b)swap(a,b);\n        int k = mm[b-a+1];\n        return rmq[dp[a][k]] <= \n        rmq[dp[b-(1<<k)+1][k]]?dp[a][k]:dp[b-(1<<k)+1][k];\n    }\n};\n```\n\n例：hdu-5726 解决区间最小公倍数\n","slug":"acm/markdown/数据结构/稀疏表","published":1,"updated":"2017-08-27T11:44:29.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoeckn000wuowo2401p8lo","content":"<h2 id=\"Spared-Table-（用于解决多种RMQ问题）\"><a href=\"#Spared-Table-（用于解决多种RMQ问题）\" class=\"headerlink\" title=\"Spared Table （用于解决多种RMQ问题）\"></a>Spared Table （用于解决多种RMQ问题）</h2><p>模板：<br>（解决区间极小值）<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">ST用来O（nlogn）时间预处理，O（1）时间查询最大最小值</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span>  </span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span>  </span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">/*方程 </span></div><div class=\"line\">F[i,j]:区间[i,i + 2^j - 1]的最小值，此时区间长度为2^j </div><div class=\"line\">F[i,j] = min(F[i,j - 1],F[i + 2^(j - 1),j - 1]) </div><div class=\"line\">F[i,0] = nArr[i];*/  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">10010</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> rmq[<span class=\"number\">2</span>*MAXN];<span class=\"comment\">//rmq数组,就是欧拉序列对应的深度序列</span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">struct</span> ST</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> mm[<span class=\"number\">2</span>*MAXN];<span class=\"comment\">//意思是向下取log2(k)</span></div><div class=\"line\">    <span class=\"keyword\">int</span> dp[<span class=\"number\">2</span>*MAXN][<span class=\"number\">20</span>];<span class=\"comment\">//最小值对应的下标</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        mm[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            mm[i] = ((i&amp;(i<span class=\"number\">-1</span>)) == <span class=\"number\">0</span>)?mm[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>:mm[i<span class=\"number\">-1</span>];</div><div class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= mm[n];j++)</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i + (<span class=\"number\">1</span>&lt;&lt;j) - <span class=\"number\">1</span> &lt;= n; i++)</div><div class=\"line\">                dp[i][j] = rmq[dp[i][j<span class=\"number\">-1</span>]] &lt;</div><div class=\"line\">                rmq[dp[i+(<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))][j<span class=\"number\">-1</span>]]?dp[i][j<span class=\"number\">-1</span>]:dp[i+(<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))][j<span class=\"number\">-1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span><span class=\"comment\">//查询[a,b]之间最小值的下标</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(a &gt; b)swap(a,b);</div><div class=\"line\">        <span class=\"keyword\">int</span> k = mm[b-a+<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">return</span> rmq[dp[a][k]] &lt;= </div><div class=\"line\">        rmq[dp[b-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span>][k]]?dp[a][k]:dp[b-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span>][k];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>例：hdu-5726 解决区间最小公倍数</p>\n","excerpt":"","more":"<h2 id=\"Spared-Table-（用于解决多种RMQ问题）\"><a href=\"#Spared-Table-（用于解决多种RMQ问题）\" class=\"headerlink\" title=\"Spared Table （用于解决多种RMQ问题）\"></a>Spared Table （用于解决多种RMQ问题）</h2><p>模板：<br>（解决区间极小值）<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</div><div class=\"line\">ST用来O（nlogn）时间预处理，O（1）时间查询最大最小值</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span>  </span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;math.h&gt;</span>  </span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">/*方程 </div><div class=\"line\">F[i,j]:区间[i,i + 2^j - 1]的最小值，此时区间长度为2^j </div><div class=\"line\">F[i,j] = min(F[i,j - 1],F[i + 2^(j - 1),j - 1]) </div><div class=\"line\">F[i,0] = nArr[i];*/</span>  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">10010</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> rmq[<span class=\"number\">2</span>*MAXN];<span class=\"comment\">//rmq数组,就是欧拉序列对应的深度序列</span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">struct</span> ST</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> mm[<span class=\"number\">2</span>*MAXN];<span class=\"comment\">//意思是向下取log2(k)</span></div><div class=\"line\">    <span class=\"keyword\">int</span> dp[<span class=\"number\">2</span>*MAXN][<span class=\"number\">20</span>];<span class=\"comment\">//最小值对应的下标</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        mm[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            mm[i] = ((i&amp;(i<span class=\"number\">-1</span>)) == <span class=\"number\">0</span>)?mm[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>:mm[i<span class=\"number\">-1</span>];</div><div class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= mm[n];j++)</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i + (<span class=\"number\">1</span>&lt;&lt;j) - <span class=\"number\">1</span> &lt;= n; i++)</div><div class=\"line\">                dp[i][j] = rmq[dp[i][j<span class=\"number\">-1</span>]] &lt;</div><div class=\"line\">                rmq[dp[i+(<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))][j<span class=\"number\">-1</span>]]?dp[i][j<span class=\"number\">-1</span>]:dp[i+(<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))][j<span class=\"number\">-1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span><span class=\"comment\">//查询[a,b]之间最小值的下标</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(a &gt; b)swap(a,b);</div><div class=\"line\">        <span class=\"keyword\">int</span> k = mm[b-a+<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"keyword\">return</span> rmq[dp[a][k]] &lt;= </div><div class=\"line\">        rmq[dp[b-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span>][k]]?dp[a][k]:dp[b-(<span class=\"number\">1</span>&lt;&lt;k)+<span class=\"number\">1</span>][k];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>例：hdu-5726 解决区间最小公倍数</p>\n"},{"title":"Uva-14149 二分图匹配求最小点覆盖","date":"2017-08-28T04:03:34.000Z","_content":"\n# Uva-14149\n## 题意：   \n给一个R*C的矩形网格，每一个小格子内可能有点，求最小选多少行多少列可以覆盖所有的点，并输出这些行和列\n\n\n## 题解：\n由于类似一个覆盖问题，可以想办法根据矩阵的二维性质构造一个二分图求最小覆盖 。  \n那么使每一行为一个点集每一列为一个点集，(x,y)有点则在x和y之间连一条线。那么最后只需要选点覆盖所有线就行。  \n二分匹配->最小点覆盖  \n要具体求出哪些点参考以下结论\n### 一个结论\n**从二分最大匹配找到最小点覆盖**    \n需要借助匈牙利树： 设二分图两个集合为X Y  \n从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖\n\n```c++\nint R,C,N;\nint uN,vN;\nint G[MAXN][MAXN];\nint Left[MAXN];\nint Right[MAXN];\nbool S[MAXN],T[MAXN];\n\nbool dfs(int u)\n{\n    S[u] = true;\n    for(int v=1; v<=vN;v++)\n    if(G[u][v] && !T[v]){\n        T[v] = true;\n        if(Left[v] == -1 || dfs(Left[v])){\n            Right[u] = v;\n            Left[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(Left,-1,sizeof(Left));\n    memset(Right,-1,sizeof(Right));\n    for(int u=1; u<=uN; u++){\n        memset(T,0,sizeof(T));\n        if(dfs(u)) res++;\n    }\n    return res;\n}\n\nint min_cover(vector<int> &X,vector<int> &Y)\n{\n    int ans = hungary();\n    X.clear();  Y.clear();\n    memset(S,0,sizeof(S));\n    memset(T,0,sizeof(T));\n    for(int i=1;i<=uN;i++)\n        if(Right[i]==-1) dfs(i);\n    for(int i=1;i<=uN;i++)\n        if(!S[i]) X.pb(i);\n    for(int j=1;j<=vN;j++)\n        if(T[j]) Y.pb(j);\n    return ans;\n}\n\nint main()\n{\n    vector<int> x,y;\n    while(scanf(\"%d%d%d\",&R,&C,&N)){\n        if(R==0 && C==0 && N==0)\n            break;\n        uN = R; vN = C;\n        memset(G,0,sizeof(G));\n        for(int i=0; i<N; i++){\n            int y,x;\n            sc(y); sc(x);\n            G[y][x] = 1;\n        }\n        int ans = min_cover(x,y);\n        printf(\"%d\",ans);\n        for(int i=0; i<x.size(); i++)\n            printf(\" r%d\",x[i]);\n        for(int i=0; i<y.size(); i++)\n            printf(\" c%d\",y[i]);\n        printf(\"\\n\");\n    }\n}\n```","source":"_posts/acm/题解/图论/二分图/Uva-14149 二分图匹配求最小点覆盖.md","raw":"---\ntitle: Uva-14149 二分图匹配求最小点覆盖\ndate: 2017-8-28 12:03:34\ncategories: ACM\ntags:  [二分图,最小点覆盖]\n---\n\n# Uva-14149\n## 题意：   \n给一个R*C的矩形网格，每一个小格子内可能有点，求最小选多少行多少列可以覆盖所有的点，并输出这些行和列\n\n\n## 题解：\n由于类似一个覆盖问题，可以想办法根据矩阵的二维性质构造一个二分图求最小覆盖 。  \n那么使每一行为一个点集每一列为一个点集，(x,y)有点则在x和y之间连一条线。那么最后只需要选点覆盖所有线就行。  \n二分匹配->最小点覆盖  \n要具体求出哪些点参考以下结论\n### 一个结论\n**从二分最大匹配找到最小点覆盖**    \n需要借助匈牙利树： 设二分图两个集合为X Y  \n从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖\n\n```c++\nint R,C,N;\nint uN,vN;\nint G[MAXN][MAXN];\nint Left[MAXN];\nint Right[MAXN];\nbool S[MAXN],T[MAXN];\n\nbool dfs(int u)\n{\n    S[u] = true;\n    for(int v=1; v<=vN;v++)\n    if(G[u][v] && !T[v]){\n        T[v] = true;\n        if(Left[v] == -1 || dfs(Left[v])){\n            Right[u] = v;\n            Left[v] = u;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary()\n{\n    int res = 0;\n    memset(Left,-1,sizeof(Left));\n    memset(Right,-1,sizeof(Right));\n    for(int u=1; u<=uN; u++){\n        memset(T,0,sizeof(T));\n        if(dfs(u)) res++;\n    }\n    return res;\n}\n\nint min_cover(vector<int> &X,vector<int> &Y)\n{\n    int ans = hungary();\n    X.clear();  Y.clear();\n    memset(S,0,sizeof(S));\n    memset(T,0,sizeof(T));\n    for(int i=1;i<=uN;i++)\n        if(Right[i]==-1) dfs(i);\n    for(int i=1;i<=uN;i++)\n        if(!S[i]) X.pb(i);\n    for(int j=1;j<=vN;j++)\n        if(T[j]) Y.pb(j);\n    return ans;\n}\n\nint main()\n{\n    vector<int> x,y;\n    while(scanf(\"%d%d%d\",&R,&C,&N)){\n        if(R==0 && C==0 && N==0)\n            break;\n        uN = R; vN = C;\n        memset(G,0,sizeof(G));\n        for(int i=0; i<N; i++){\n            int y,x;\n            sc(y); sc(x);\n            G[y][x] = 1;\n        }\n        int ans = min_cover(x,y);\n        printf(\"%d\",ans);\n        for(int i=0; i<x.size(); i++)\n            printf(\" r%d\",x[i]);\n        for(int i=0; i<y.size(); i++)\n            printf(\" c%d\",y[i]);\n        printf(\"\\n\");\n    }\n}\n```","slug":"acm/题解/图论/二分图/Uva-14149 二分图匹配求最小点覆盖","published":1,"updated":"2017-08-27T11:50:40.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6uoecmt001kuowoz5lq3s2c","content":"<h1 id=\"Uva-14149\"><a href=\"#Uva-14149\" class=\"headerlink\" title=\"Uva-14149\"></a>Uva-14149</h1><h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>给一个R*C的矩形网格，每一个小格子内可能有点，求最小选多少行多少列可以覆盖所有的点，并输出这些行和列</p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>由于类似一个覆盖问题，可以想办法根据矩阵的二维性质构造一个二分图求最小覆盖 。<br>那么使每一行为一个点集每一列为一个点集，(x,y)有点则在x和y之间连一条线。那么最后只需要选点覆盖所有线就行。<br>二分匹配-&gt;最小点覆盖<br>要具体求出哪些点参考以下结论</p>\n<h3 id=\"一个结论\"><a href=\"#一个结论\" class=\"headerlink\" title=\"一个结论\"></a>一个结论</h3><p><strong>从二分最大匹配找到最小点覆盖</strong><br>需要借助匈牙利树： 设二分图两个集合为X Y<br>从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> R,C,N;</div><div class=\"line\"><span class=\"keyword\">int</span> uN,vN;</div><div class=\"line\"><span class=\"keyword\">int</span> G[MAXN][MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Left[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Right[MAXN];</div><div class=\"line\"><span class=\"keyword\">bool</span> S[MAXN],T[MAXN];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    S[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v=<span class=\"number\">1</span>; v&lt;=vN;v++)</div><div class=\"line\">    <span class=\"keyword\">if</span>(G[u][v] &amp;&amp; !T[v])&#123;</div><div class=\"line\">        T[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(Left[v] == <span class=\"number\">-1</span> || dfs(Left[v]))&#123;</div><div class=\"line\">            Right[u] = v;</div><div class=\"line\">            Left[v] = u;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hungary</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Left,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Left));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Right,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Right));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u=<span class=\"number\">1</span>; u&lt;=uN; u++)&#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">        <span class=\"keyword\">if</span>(dfs(u)) res++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cover</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;X,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Y)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = hungary();</div><div class=\"line\">    X.clear();  Y.clear();</div><div class=\"line\">    <span class=\"built_in\">memset</span>(S,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(S));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(Right[i]==<span class=\"number\">-1</span>) dfs(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(!S[i]) X.pb(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=vN;j++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(T[j]) Y.pb(j);</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; x,y;</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;R,&amp;C,&amp;N))&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(R==<span class=\"number\">0</span> &amp;&amp; C==<span class=\"number\">0</span> &amp;&amp; N==<span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        uN = R; vN = C;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(G,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(G));</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> y,x;</div><div class=\"line\">            sc(y); sc(x);</div><div class=\"line\">            G[y][x] = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = min_cover(x,y);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,ans);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;x.size(); i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" r%d\"</span>,x[i]);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;y.size(); i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" c%d\"</span>,y[i]);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h1 id=\"Uva-14149\"><a href=\"#Uva-14149\" class=\"headerlink\" title=\"Uva-14149\"></a>Uva-14149</h1><h2 id=\"题意：\"><a href=\"#题意：\" class=\"headerlink\" title=\"题意：\"></a>题意：</h2><p>给一个R*C的矩形网格，每一个小格子内可能有点，求最小选多少行多少列可以覆盖所有的点，并输出这些行和列</p>\n<h2 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h2><p>由于类似一个覆盖问题，可以想办法根据矩阵的二维性质构造一个二分图求最小覆盖 。<br>那么使每一行为一个点集每一列为一个点集，(x,y)有点则在x和y之间连一条线。那么最后只需要选点覆盖所有线就行。<br>二分匹配-&gt;最小点覆盖<br>要具体求出哪些点参考以下结论</p>\n<h3 id=\"一个结论\"><a href=\"#一个结论\" class=\"headerlink\" title=\"一个结论\"></a>一个结论</h3><p><strong>从二分最大匹配找到最小点覆盖</strong><br>需要借助匈牙利树： 设二分图两个集合为X Y<br>从X中所有未覆盖点出发进行扩展匈牙利树，标记树当中的所有点，则X当中的未标记点和Y当中的已标记点组成了所求的最小覆盖</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> R,C,N;</div><div class=\"line\"><span class=\"keyword\">int</span> uN,vN;</div><div class=\"line\"><span class=\"keyword\">int</span> G[MAXN][MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Left[MAXN];</div><div class=\"line\"><span class=\"keyword\">int</span> Right[MAXN];</div><div class=\"line\"><span class=\"keyword\">bool</span> S[MAXN],T[MAXN];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    S[u] = <span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> v=<span class=\"number\">1</span>; v&lt;=vN;v++)</div><div class=\"line\">    <span class=\"keyword\">if</span>(G[u][v] &amp;&amp; !T[v])&#123;</div><div class=\"line\">        T[v] = <span class=\"literal\">true</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(Left[v] == <span class=\"number\">-1</span> || dfs(Left[v]))&#123;</div><div class=\"line\">            Right[u] = v;</div><div class=\"line\">            Left[v] = u;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hungary</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Left,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Left));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(Right,<span class=\"number\">-1</span>,<span class=\"keyword\">sizeof</span>(Right));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> u=<span class=\"number\">1</span>; u&lt;=uN; u++)&#123;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">        <span class=\"keyword\">if</span>(dfs(u)) res++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cover</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;X,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;Y)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> ans = hungary();</div><div class=\"line\">    X.clear();  Y.clear();</div><div class=\"line\">    <span class=\"built_in\">memset</span>(S,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(S));</div><div class=\"line\">    <span class=\"built_in\">memset</span>(T,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(T));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(Right[i]==<span class=\"number\">-1</span>) dfs(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=uN;i++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(!S[i]) X.pb(i);</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=vN;j++)</div><div class=\"line\">        <span class=\"keyword\">if</span>(T[j]) Y.pb(j);</div><div class=\"line\">    <span class=\"keyword\">return</span> ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; x,y;</div><div class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d\"</span>,&amp;R,&amp;C,&amp;N))&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(R==<span class=\"number\">0</span> &amp;&amp; C==<span class=\"number\">0</span> &amp;&amp; N==<span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        uN = R; vN = C;</div><div class=\"line\">        <span class=\"built_in\">memset</span>(G,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(G));</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;N; i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> y,x;</div><div class=\"line\">            sc(y); sc(x);</div><div class=\"line\">            G[y][x] = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = min_cover(x,y);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,ans);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;x.size(); i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" r%d\"</span>,x[i]);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;y.size(); i++)</div><div class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\" c%d\"</span>,y[i]);</div><div class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj6ujd9kp0002b8wowoxx45nv","category_id":"cj6ujd9lh0004b8woi1qjgrd9","_id":"cj6ujd9m50007b8wo1lv7d18f"},{"post_id":"cj6ujda0e000kb8wo3d863rzs","category_id":"cj6ujda0q000pb8wo0ow03jeg","_id":"cj6ujda12000xb8woynu6p3ht"},{"post_id":"cj6ujda6q001cb8woqsnbn0hq","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6ujda6y001eb8wonbihv19j"},{"post_id":"cj6uoecee0000uowo14cz3s7e","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecf30004uowo19we0aik"},{"post_id":"cj6uoecex0001uowogvk75eve","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecfy0007uowo6okg7vvg"},{"post_id":"cj6uoecf30003uowokqfqsvnv","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecge000auowo97gf4qlf"},{"post_id":"cj6uoecfj0006uowo5jm7f9yt","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecge000duowo56epbwx8"},{"post_id":"cj6uoecfy0009uowoggcwwyjx","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecge000fuowob3fp5k9d"},{"post_id":"cj6uoecge000cuowo5m5deeyz","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecge000huowo32tg9vie"},{"post_id":"cj6uoecj6000luowohh86jpo0","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoeck1000puowo1izibm6i"},{"post_id":"cj6uoecj6000muowo8alirldh","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoeckj000ruowo6dqd5zbt"},{"post_id":"cj6uoeck1000ouowoszso4zyo","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoeckn000uuowo1fhqry54"},{"post_id":"cj6uoeck1000quowo60hubzf5","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoeckn000xuowoktb2jaw4"},{"post_id":"cj6uoeckk000suowod783zktp","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoeckn0010uowo3bswcopr"},{"post_id":"cj6uoeckn000wuowo2401p8lo","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoeckn0012uowoyeqydj23"},{"post_id":"cj6uoecmt001kuowoz5lq3s2c","category_id":"cj6ujd9y6000ab8wofplz8vz4","_id":"cj6uoecnc001muowolh0bp1oa"}],"PostTag":[{"post_id":"cj6ujd9kp0002b8wowoxx45nv","tag_id":"cj6ujd9lv0005b8woe098r5h0","_id":"cj6ujd9m10006b8wojtbsc3vk"},{"post_id":"cj6ujda0e000kb8wo3d863rzs","tag_id":"cj6ujda220017b8woijcrzmk3","_id":"cj6ujda26001ab8won392vs1p"},{"post_id":"cj6ujda0e000kb8wo3d863rzs","tag_id":"cj6ujda220019b8woxmant0kv","_id":"cj6ujda26001bb8wonrqx1hoc"},{"post_id":"cj6ujda6q001cb8woqsnbn0hq","tag_id":"cj6ujda6y001db8wofkn32zbk","_id":"cj6ujda73001gb8wofh6k9up0"},{"post_id":"cj6ujda6q001cb8woqsnbn0hq","tag_id":"cj6ujda0m000mb8woslxknh04","_id":"cj6ujda73001hb8womhbps9fd"},{"post_id":"cj6ujda6q001cb8woqsnbn0hq","tag_id":"cj6ujda6y001fb8wownayr93y","_id":"cj6ujda73001ib8wos26i8mze"},{"post_id":"cj6uoecee0000uowo14cz3s7e","tag_id":"cj6ujda16000yb8wojnpl8b7s","_id":"cj6uoecf30002uowokxe38i2r"},{"post_id":"cj6uoecex0001uowogvk75eve","tag_id":"cj6ujd9y6000bb8woisyu6wa0","_id":"cj6uoecf30005uowoh9s511lw"},{"post_id":"cj6uoecf30003uowokqfqsvnv","tag_id":"cj6ujd9za000gb8woxg6te0z9","_id":"cj6uoecfy0008uowondq32lqk"},{"post_id":"cj6uoecf30003uowokqfqsvnv","tag_id":"cj6ujda0m000mb8woslxknh04","_id":"cj6uoecge000buowobcrrk4wq"},{"post_id":"cj6uoecfj0006uowo5jm7f9yt","tag_id":"cj6ujda16000yb8wojnpl8b7s","_id":"cj6uoecge000euowo5authggq"},{"post_id":"cj6uoecfj0006uowo5jm7f9yt","tag_id":"cj6ujda0m000mb8woslxknh04","_id":"cj6uoecge000guowol2u6rzjr"},{"post_id":"cj6uoecfy0009uowoggcwwyjx","tag_id":"cj6ujd9za000gb8woxg6te0z9","_id":"cj6uoecge000iuowojn700jxz"},{"post_id":"cj6uoecfy0009uowoggcwwyjx","tag_id":"cj6ujda12000vb8wovhd8916k","_id":"cj6uoecge000juowo3rthni45"},{"post_id":"cj6uoecge000cuowo5m5deeyz","tag_id":"cj6ujda16000yb8wojnpl8b7s","_id":"cj6uoecge000kuowowvywt28k"},{"post_id":"cj6uoecj6000luowohh86jpo0","tag_id":"cj6ujd9za000gb8woxg6te0z9","_id":"cj6uoeckn000vuowovgorqph0"},{"post_id":"cj6uoecj6000luowohh86jpo0","tag_id":"cj6uoecj6000nuowojrpqxcgm","_id":"cj6uoeckn000yuowonq6i0w61"},{"post_id":"cj6uoecj6000muowo8alirldh","tag_id":"cj6ujd9za000gb8woxg6te0z9","_id":"cj6uoeckn0011uowotndsbt4s"},{"post_id":"cj6uoecj6000muowo8alirldh","tag_id":"cj6uoeckn000tuowohknf71gn","_id":"cj6uoeckn0013uowom16m2cvf"},{"post_id":"cj6uoeck1000ouowoszso4zyo","tag_id":"cj6ujd9za000gb8woxg6te0z9","_id":"cj6uoeckn0015uowocwkz6xsm"},{"post_id":"cj6uoeck1000ouowoszso4zyo","tag_id":"cj6uoeckn000zuowosyp0qbah","_id":"cj6uoecl30016uowoc8w2ybkp"},{"post_id":"cj6uoeck1000quowo60hubzf5","tag_id":"cj6uoeckn0014uowob0dw66dx","_id":"cj6uoecl30018uowolykwimqa"},{"post_id":"cj6uoeckk000suowod783zktp","tag_id":"cj6uoecl30017uowo11eerzlv","_id":"cj6uoecl3001duowo11crz6pa"},{"post_id":"cj6uoeckk000suowod783zktp","tag_id":"cj6uoecl30019uowow7epbcsv","_id":"cj6uoecl3001euowopo7hq4m2"},{"post_id":"cj6uoeckk000suowod783zktp","tag_id":"cj6uoecl3001auowo8jhwsvqv","_id":"cj6uoecli001guowouuqru23y"},{"post_id":"cj6uoeckk000suowod783zktp","tag_id":"cj6uoecl3001buowo235cfmap","_id":"cj6uoecli001huowo14u2dmqm"},{"post_id":"cj6uoeckn000wuowo2401p8lo","tag_id":"cj6uoecl3001cuowoc7ksclcb","_id":"cj6uoecli001iuowo3em1nmaz"},{"post_id":"cj6uoeckn000wuowo2401p8lo","tag_id":"cj6uoecl3001fuowo9u4hxeku","_id":"cj6uoecli001juowo8bm5t1k8"},{"post_id":"cj6uoecmt001kuowoz5lq3s2c","tag_id":"cj6uoeckn0014uowob0dw66dx","_id":"cj6uoecnd001nuowor5ld92a3"},{"post_id":"cj6uoecmt001kuowoz5lq3s2c","tag_id":"cj6uoecnb001luowoxqe22br1","_id":"cj6uoecne001ouowofcr032zv"}],"Tag":[{"name":"随想","_id":"cj6ujd9lv0005b8woe098r5h0"},{"name":"动态规划","_id":"cj6ujd9y6000bb8woisyu6wa0"},{"name":"数论","_id":"cj6ujd9za000gb8woxg6te0z9"},{"name":"题解","_id":"cj6ujda0m000mb8woslxknh04"},{"name":"快速幂","_id":"cj6ujda12000vb8wovhd8916k"},{"name":"博弈论","_id":"cj6ujda16000yb8wojnpl8b7s"},{"name":"数据挖掘","_id":"cj6ujda220017b8woijcrzmk3"},{"name":"图","_id":"cj6ujda220019b8woxmant0kv"},{"name":"比赛","_id":"cj6ujda6y001db8wofkn32zbk"},{"name":"三元环","_id":"cj6ujda6y001fb8wownayr93y"},{"name":"异或","_id":"cj6uoecj6000nuowojrpqxcgm"},{"name":"线性筛法","_id":"cj6uoeckn000tuowohknf71gn"},{"name":"欧拉函数","_id":"cj6uoeckn000zuowosyp0qbah"},{"name":"二分图","_id":"cj6uoeckn0014uowob0dw66dx"},{"name":"最小瓶颈树","_id":"cj6uoecl30017uowo11eerzlv"},{"name":"kruskal","_id":"cj6uoecl30019uowow7epbcsv"},{"name":"倍增法","_id":"cj6uoecl3001auowo8jhwsvqv"},{"name":"LCA","_id":"cj6uoecl3001buowo235cfmap"},{"name":"RMQ","_id":"cj6uoecl3001cuowoc7ksclcb"},{"name":"稀疏表","_id":"cj6uoecl3001fuowo9u4hxeku"},{"name":"最小点覆盖","_id":"cj6uoecnb001luowoxqe22br1"}]}}